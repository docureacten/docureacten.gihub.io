"use strict";(self.webpackChunkdocubook=self.webpackChunkdocubook||[]).push([[9595],{3646:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>a,contentTitle:()=>t,default:()=>p,frontMatter:()=>o,metadata:()=>c,toc:()=>l});var s=i(4848),r=i(8453);const o={},t="Techniques for Optimizing Rendering",c={id:"Optimization/8-2-Techniques for Optimizing Rendering",title:"Techniques for Optimizing Rendering",description:"When working with React, one of the most crucial aspects to consider is rendering performance. As your application grows in complexity, inefficient rendering can lead to sluggish performance, causing a poor user experience. Optimizing rendering involves techniques that ensure your React components only re-render when absolutely necessary. This section will walk you through several techniques and best practices for achieving optimal rendering performance in React.",source:"@site/docs/8-Optimization/8-2-Techniques for Optimizing Rendering.md",sourceDirName:"8-Optimization",slug:"/Optimization/8-2-Techniques for Optimizing Rendering",permalink:"/Optimization/8-2-Techniques for Optimizing Rendering",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Techniques for Optimizing Component Performance",permalink:"/Optimization/8-1-Techniques for Optimizing Component Performance"},next:{title:"Inline Styling",permalink:"/Style/9-1-Inline Styling"}},a={},l=[{value:"1. Understanding the Component Re-rendering Process",id:"1-understanding-the-component-re-rendering-process",level:2},{value:"2. Using <code>React.memo</code> for Pure Components",id:"2-using-reactmemo-for-pure-components",level:2},{value:"Example:",id:"example",level:3},{value:"3. Avoiding Anonymous Functions in JSX",id:"3-avoiding-anonymous-functions-in-jsx",level:2},{value:"Example:",id:"example-1",level:3},{value:"4. Utilizing <code>useMemo</code> for Expensive Calculations",id:"4-utilizing-usememo-for-expensive-calculations",level:2},{value:"Example:",id:"example-2",level:3},{value:"5. Optimizing Lists with <code>key</code> Props",id:"5-optimizing-lists-with-key-props",level:2},{value:"Example:",id:"example-3",level:3},{value:"6. Using <code>shouldComponentUpdate</code> in Class Components",id:"6-using-shouldcomponentupdate-in-class-components",level:2},{value:"Example:",id:"example-4",level:3},{value:"Further Reading",id:"further-reading",level:2},{value:"Summary",id:"summary",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h1,{id:"techniques-for-optimizing-rendering",children:"Techniques for Optimizing Rendering"}),"\n",(0,s.jsx)(n.p,{children:"When working with React, one of the most crucial aspects to consider is rendering performance. As your application grows in complexity, inefficient rendering can lead to sluggish performance, causing a poor user experience. Optimizing rendering involves techniques that ensure your React components only re-render when absolutely necessary. This section will walk you through several techniques and best practices for achieving optimal rendering performance in React."}),"\n",(0,s.jsx)(n.h2,{id:"1-understanding-the-component-re-rendering-process",children:"1. Understanding the Component Re-rendering Process"}),"\n",(0,s.jsx)(n.p,{children:"Before diving into optimization techniques, it's essential to understand why and when components re-render. In React, a component re-renders when:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Its ",(0,s.jsx)(n.code,{children:"state"})," changes."]}),"\n",(0,s.jsxs)(n.li,{children:["Its ",(0,s.jsx)(n.code,{children:"props"})," change."]}),"\n",(0,s.jsx)(n.li,{children:"Its parent component re-renders."}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"However, unnecessary re-renders can occur, leading to performance issues. For example, passing a new object or function reference as a prop, even if its contents haven't changed, can trigger a re-render. Knowing this helps us apply optimization techniques more effectively."}),"\n",(0,s.jsxs)(n.h2,{id:"2-using-reactmemo-for-pure-components",children:["2. Using ",(0,s.jsx)(n.code,{children:"React.memo"})," for Pure Components"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"React.memo"})," is a higher-order component that prevents unnecessary re-renders for functional components. If the props passed to the component do not change, ",(0,s.jsx)(n.code,{children:"React.memo"})," will reuse the last rendered output, skipping the render process."]}),"\n",(0,s.jsx)(n.h3,{id:"example",children:"Example:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'import React from \'react\';\n\n// A simple functional component\nconst Greeting = React.memo(({ name }) => {\n  console.log("Greeting component re-rendered!");\n  return <h1>Hello, {name}!</h1>;\n});\n\n// Parent component\nconst ParentComponent = () => {\n  const [count, setCount] = React.useState(0);\n\n  return (\n    <div>\n      <Greeting name="Alice" />\n      <button onClick={() => setCount(count + 1)}>\n        Increment Count\n      </button>\n      <p>Count: {count}</p>\n    </div>\n  );\n};\n\nexport default ParentComponent;\n'})}),"\n",(0,s.jsxs)(n.p,{children:["In this example, the ",(0,s.jsx)(n.code,{children:"Greeting"})," component won't re-render when the count changes because ",(0,s.jsx)(n.code,{children:"React.memo"})," ensures that it only re-renders if the ",(0,s.jsx)(n.code,{children:"name"})," prop changes."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Key Point"}),": Use ",(0,s.jsx)(n.code,{children:"React.memo"})," to optimize functional components, especially when they receive props that don't frequently change."]}),"\n",(0,s.jsx)(n.h2,{id:"3-avoiding-anonymous-functions-in-jsx",children:"3. Avoiding Anonymous Functions in JSX"}),"\n",(0,s.jsx)(n.p,{children:"Passing anonymous functions as props can cause child components to re-render unnecessarily because a new function reference is created on every render."}),"\n",(0,s.jsx)(n.h3,{id:"example-1",children:"Example:"}),"\n",(0,s.jsx)(n.p,{children:"Instead of this:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"<button onClick={() => handleClick(id)}>Click me</button>\n"})}),"\n",(0,s.jsx)(n.p,{children:"Refactor to:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"const handleClick = React.useCallback((id) => {\n  // handle click logic\n}, []);\n\n<button onClick={handleClick}>Click me</button>\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Using ",(0,s.jsx)(n.code,{children:"React.useCallback"}),", you can ensure that the same function reference is used across renders, preventing unnecessary re-renders."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Key Point"}),": Use ",(0,s.jsx)(n.code,{children:"React.useCallback"})," for event handlers and functions passed as props to avoid re-rendering due to new function references."]}),"\n",(0,s.jsxs)(n.h2,{id:"4-utilizing-usememo-for-expensive-calculations",children:["4. Utilizing ",(0,s.jsx)(n.code,{children:"useMemo"})," for Expensive Calculations"]}),"\n",(0,s.jsxs)(n.p,{children:["If your component performs expensive calculations during rendering, ",(0,s.jsx)(n.code,{children:"useMemo"})," can be used to memoize the result, recalculating it only when its dependencies change."]}),"\n",(0,s.jsx)(n.h3,{id:"example-2",children:"Example:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"const ExpensiveComponent = ({ num }) => {\n  const factorial = React.useMemo(() => {\n    const computeFactorial = (n) => {\n      if (n <= 1) return 1;\n      return n * computeFactorial(n - 1);\n    };\n    return computeFactorial(num);\n  }, [num]);\n\n  return <div>Factorial: {factorial}</div>;\n};\n"})}),"\n",(0,s.jsxs)(n.p,{children:["In this example, the factorial is only recalculated when ",(0,s.jsx)(n.code,{children:"num"})," changes, preventing unnecessary computations."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Key Point"}),": Use ",(0,s.jsx)(n.code,{children:"React.useMemo"})," for expensive calculations or data processing to avoid re-computation during each render."]}),"\n",(0,s.jsxs)(n.h2,{id:"5-optimizing-lists-with-key-props",children:["5. Optimizing Lists with ",(0,s.jsx)(n.code,{children:"key"})," Props"]}),"\n",(0,s.jsxs)(n.p,{children:["When rendering lists in React, using the ",(0,s.jsx)(n.code,{children:"key"})," prop correctly is essential. The ",(0,s.jsx)(n.code,{children:"key"})," helps React identify which items have changed, been added, or removed. A stable and unique key prevents unnecessary re-renders and ensures efficient updates."]}),"\n",(0,s.jsx)(n.h3,{id:"example-3",children:"Example:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"const UserList = ({ users }) => {\n  return (\n    <ul>\n      {users.map((user) => (\n        <li key={user.id}>{user.name}</li>\n      ))}\n    </ul>\n  );\n};\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Always use a unique and stable key, like an ",(0,s.jsx)(n.code,{children:"id"}),", rather than using the array index, which can lead to bugs and performance issues when the list order changes."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Key Point"}),": Ensure that each list item has a unique and stable ",(0,s.jsx)(n.code,{children:"key"})," prop to optimize rendering performance."]}),"\n",(0,s.jsxs)(n.h2,{id:"6-using-shouldcomponentupdate-in-class-components",children:["6. Using ",(0,s.jsx)(n.code,{children:"shouldComponentUpdate"})," in Class Components"]}),"\n",(0,s.jsxs)(n.p,{children:["For class components, the ",(0,s.jsx)(n.code,{children:"shouldComponentUpdate"})," lifecycle method provides control over re-renders. You can compare the current and next props/state to decide if a re-render is necessary."]}),"\n",(0,s.jsx)(n.h3,{id:"example-4",children:"Example:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"class UserProfile extends React.Component {\n  shouldComponentUpdate(nextProps, nextState) {\n    return nextProps.user.id !== this.props.user.id;\n  }\n\n  render() {\n    const { user } = this.props;\n    return <div>{user.name}</div>;\n  }\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Here, the ",(0,s.jsx)(n.code,{children:"UserProfile"})," component only re-renders when the ",(0,s.jsx)(n.code,{children:"user.id"})," changes, avoiding unnecessary renders."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Key Point"}),": Use ",(0,s.jsx)(n.code,{children:"shouldComponentUpdate"})," in class components to fine-tune when re-renders should occur."]}),"\n",(0,s.jsx)(n.h2,{id:"further-reading",children:"Further Reading"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.strong,{children:"React.memo"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.strong,{children:"useCallback"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.strong,{children:"useMemo"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.strong,{children:"shouldComponentUpdate"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.strong,{children:"React Rendering Optimization"})}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,s.jsxs)(n.p,{children:["Optimizing rendering in React involves techniques such as using ",(0,s.jsx)(n.code,{children:"React.memo"})," to prevent unnecessary re-renders, avoiding anonymous functions in JSX, leveraging ",(0,s.jsx)(n.code,{children:"useMemo"})," for expensive calculations, using proper ",(0,s.jsx)(n.code,{children:"key"})," props for lists, and implementing ",(0,s.jsx)(n.code,{children:"shouldComponentUpdate"})," in class components. These practices help maintain a responsive and efficient user interface, even as your application scales."]})]})}function p(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>t,x:()=>c});var s=i(6540);const r={},o=s.createContext(r);function t(e){const n=s.useContext(o);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:t(e.components),s.createElement(o.Provider,{value:n},e.children)}}}]);