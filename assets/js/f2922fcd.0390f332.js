"use strict";(self.webpackChunkdocubook=self.webpackChunkdocubook||[]).push([[1075],{9887:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>r,default:()=>h,frontMatter:()=>i,metadata:()=>a,toc:()=>l});var o=t(4848),s=t(8453);const i={},r="Higher-Order Components (HOC)",a={id:"Component/5-8-Higher-Order Components (HOC)",title:"Higher-Order Components (HOC)",description:"Higher-Order Components (HOCs) are a powerful and flexible pattern in React that allows you to reuse component logic across multiple components. Understanding HOCs is crucial for creating scalable and maintainable React applications. In this section, we'll dive into what HOCs are, how they work, and how you can use them effectively in your React projects.",source:"@site/docs/5-Component/5-8-Higher-Order Components (HOC).md",sourceDirName:"5-Component",slug:"/Component/5-8-Higher-Order Components (HOC)",permalink:"/Component/5-8-Higher-Order Components (HOC)",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Considerations When Structuring Components",permalink:"/Component/5-7-Considerations When Structuring Components"},next:{title:"Handling Whitespace in JSX",permalink:"/Rendering/6-1-Handling Whitespace in JSX"}},c={},l=[{value:"What is a Higher-Order Component?",id:"what-is-a-higher-order-component",level:2},{value:"Example: Creating and Using an HOC",id:"example-creating-and-using-an-hoc",level:3},{value:"Key Concepts and Best Practices",id:"key-concepts-and-best-practices",level:3},{value:"When to Use HOCs",id:"when-to-use-hocs",level:3},{value:"Further Reading",id:"further-reading",level:2},{value:"Summary",id:"summary",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.h1,{id:"higher-order-components-hoc",children:"Higher-Order Components (HOC)"}),"\n",(0,o.jsx)(n.p,{children:"Higher-Order Components (HOCs) are a powerful and flexible pattern in React that allows you to reuse component logic across multiple components. Understanding HOCs is crucial for creating scalable and maintainable React applications. In this section, we'll dive into what HOCs are, how they work, and how you can use them effectively in your React projects."}),"\n",(0,o.jsx)(n.h2,{id:"what-is-a-higher-order-component",children:"What is a Higher-Order Component?"}),"\n",(0,o.jsx)(n.p,{children:"A Higher-Order Component is a function that takes a component and returns a new component. The key idea behind HOCs is to allow for the sharing of logic across different components without duplicating code. Think of HOCs as a wrapper around your original component that enhances or modifies its behavior."}),"\n",(0,o.jsx)(n.p,{children:"Here's a simple definition:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-javascript",children:'const withExtraInfo = (WrappedComponent) => {\n  // Return a new component\n  return (props) => {\n    // You can add additional logic here, for example, adding new props or handling state\n    const extraInfo = "This is some extra information!";\n    \n    // Return the WrappedComponent with the original props and the new prop\n    return <WrappedComponent {...props} extraInfo={extraInfo} />;\n  };\n};\n'})}),"\n",(0,o.jsx)(n.h3,{id:"example-creating-and-using-an-hoc",children:"Example: Creating and Using an HOC"}),"\n",(0,o.jsx)(n.p,{children:"Let's say we have a simple component that displays a user's name:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-javascript",children:"const UserComponent = ({ name }) => {\n  return <div>User: {name}</div>;\n};\n"})}),"\n",(0,o.jsx)(n.p,{children:"Now, suppose we want to add some extra information to this component without modifying it directly. We can create an HOC to do this:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-javascript",children:'// Higher-Order Component that adds extra information\nconst withUserStatus = (WrappedComponent) => {\n  return (props) => {\n    const isLoggedIn = true;  // Simulate a user status\n    const statusMessage = isLoggedIn ? "Online" : "Offline";\n\n    // Pass the new prop (statusMessage) along with existing props\n    return <WrappedComponent {...props} statusMessage={statusMessage} />;\n  };\n};\n\n// Use the HOC to create a new component\nconst EnhancedUserComponent = withUserStatus(UserComponent);\n\n// Render the EnhancedUserComponent\n// This will now display both the user\'s name and their status\n<EnhancedUserComponent name="John Doe" />;\n'})}),"\n",(0,o.jsxs)(n.p,{children:["In this example, ",(0,o.jsx)(n.code,{children:"withUserStatus"})," is the Higher-Order Component that adds a ",(0,o.jsx)(n.code,{children:"statusMessage"})," prop to the original ",(0,o.jsx)(n.code,{children:"UserComponent"}),". The ",(0,o.jsx)(n.code,{children:"EnhancedUserComponent"})," is the resulting component that includes both the original behavior and the additional logic."]}),"\n",(0,o.jsx)(n.h3,{id:"key-concepts-and-best-practices",children:"Key Concepts and Best Practices"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Pure Functions:"})," HOCs should ideally be pure functions, meaning they don't modify the original component directly but instead return a new component with enhanced behavior. This ensures that the original component remains reusable and unaffected by the HOC."]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Props Handling:"})," When creating an HOC, always pass the props you receive to the wrapped component using the spread operator (",(0,o.jsx)(n.code,{children:"...props"}),"). This ensures that the original component gets all the props it expects."]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Naming Conventions:"})," It's a good practice to name your HOC functions with a prefix like ",(0,o.jsx)(n.code,{children:"with"}),", ",(0,o.jsx)(n.code,{children:"enhance"}),", or ",(0,o.jsx)(n.code,{children:"connect"}),", which clearly indicates that they are higher-order functions."]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Avoid Excessive Nesting:"})," While HOCs are powerful, overusing them or nesting multiple HOCs can lead to complex and difficult-to-debug code. It's essential to strike a balance between reusability and maintainability."]}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"when-to-use-hocs",children:"When to Use HOCs"}),"\n",(0,o.jsx)(n.p,{children:"HOCs are particularly useful in the following scenarios:"}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Cross-Cutting Concerns:"})," When you need to apply the same logic across multiple components, such as authentication checks, logging, or handling permissions."]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Conditional Rendering:"})," When you want to conditionally enhance a component's behavior based on certain props or state."]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Code Reusability:"})," When you want to encapsulate and reuse logic across different parts of your application without duplicating code."]}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"further-reading",children:"Further Reading"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.strong,{children:"React Documentation on Higher-Order Components"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.strong,{children:"Composition vs. Inheritance in React"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.strong,{children:"Reusability Patterns in React"})}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,o.jsx)(n.p,{children:"Higher-Order Components (HOCs) are a pattern in React that allows you to enhance or modify components by wrapping them in a function that returns a new component. They enable you to share logic across components, making your code more reusable and maintainable. However, it's essential to use HOCs wisely to avoid complexity and ensure your components remain easy to understand and debug. By understanding how to create and apply HOCs effectively, you can leverage this powerful tool to build more flexible and robust React applications."})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>a});var o=t(6540);const s={},i=o.createContext(s);function r(e){const n=o.useContext(i);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),o.createElement(i.Provider,{value:n},e.children)}}}]);