"use strict";(self.webpackChunkdocubook=self.webpackChunkdocubook||[]).push([[6500],{7265:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>r,metadata:()=>o,toc:()=>c});var s=i(4848),t=i(8453);const r={},a="How to Use Keys Inside Lists",o={id:"Rendering/6-3-How to Use Keys Inside Lists",title:"How to Use Keys Inside Lists",description:'In React, when rendering a list of elements, each element must have a unique identifier known as a "key." The key prop is crucial for React\'s reconciliation process, enabling it to efficiently update the user interface when data changes. Without proper keys, React will struggle to determine which items have changed, leading to potential performance issues or even incorrect rendering.',source:"@site/docs/6-Rendering/6-3-How to Use Keys Inside Lists.md",sourceDirName:"6-Rendering",slug:"/Rendering/6-3-How to Use Keys Inside Lists",permalink:"/Rendering/6-3-How to Use Keys Inside Lists",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Dealing with 0 (Zero) as a Valid Value in JSX",permalink:"/Rendering/6-2-Dealing with 0 (Zero) as a Valid Value in JSX"},next:{title:"Safely Using Raw HTML",permalink:"/Rendering/6-4-Safely Using Raw HTML"}},l={},c=[{value:"Understanding the Purpose of Keys",id:"understanding-the-purpose-of-keys",level:2},{value:"Basic Example: Rendering a List with Keys",id:"basic-example-rendering-a-list-with-keys",level:2},{value:"Explanation of the Example",id:"explanation-of-the-example",level:3},{value:"Potential Issues with Improper Keys",id:"potential-issues-with-improper-keys",level:2},{value:"What&#39;s Wrong Here?",id:"whats-wrong-here",level:3},{value:"Best Practices for Using Keys",id:"best-practices-for-using-keys",level:2},{value:"Further Reading",id:"further-reading",level:2},{value:"Summary",id:"summary",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h1,{id:"how-to-use-keys-inside-lists",children:"How to Use Keys Inside Lists"}),"\n",(0,s.jsx)(n.p,{children:'In React, when rendering a list of elements, each element must have a unique identifier known as a "key." The key prop is crucial for React\'s reconciliation process, enabling it to efficiently update the user interface when data changes. Without proper keys, React will struggle to determine which items have changed, leading to potential performance issues or even incorrect rendering.'}),"\n",(0,s.jsx)(n.h2,{id:"understanding-the-purpose-of-keys",children:"Understanding the Purpose of Keys"}),"\n",(0,s.jsx)(n.p,{children:'When you render a list in React, each element of the list is associated with a "key" to help React keep track of each item. A key is a unique identifier for an item, and it allows React to identify which items have been added, removed, or re-ordered. This process is essential for optimizing performance because React can update only the changed elements instead of re-rendering the entire list.'}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Key Concept:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Uniqueness:"})," Each key should be unique among siblings. A good practice is to use a unique value from your data, such as an ",(0,s.jsx)(n.code,{children:"id"})," or a unique attribute."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Consistency:"})," The key should remain consistent across re-renders. Avoid using indices of items as keys if the order of items might change, as this can lead to issues with React incorrectly associating keys."]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"basic-example-rendering-a-list-with-keys",children:"Basic Example: Rendering a List with Keys"}),"\n",(0,s.jsx)(n.p,{children:"Let's consider a simple example where we render a list of fruits:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-jsx",children:"import React from 'react';\n\nfunction FruitList() {\n  // Define an array of fruit objects, each with a unique id\n  const fruits = [\n    { id: 1, name: 'Apple' },\n    { id: 2, name: 'Banana' },\n    { id: 3, name: 'Cherry' },\n  ];\n\n  return (\n    <ul>\n      {/* Render each fruit as a list item with a unique key */}\n      {fruits.map(fruit => (\n        <li key={fruit.id}>\n          {fruit.name}\n        </li>\n      ))}\n    </ul>\n  );\n}\n\nexport default FruitList;\n"})}),"\n",(0,s.jsx)(n.h3,{id:"explanation-of-the-example",children:"Explanation of the Example"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Key Assignment:"})," In this example, each fruit is an object with a unique ",(0,s.jsx)(n.code,{children:"id"}),". We use this ",(0,s.jsx)(n.code,{children:"id"})," as the key prop in the ",(0,s.jsx)(n.code,{children:"<li>"})," element. This allows React to track each fruit uniquely."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Map Function:"})," We use the ",(0,s.jsx)(n.code,{children:"map()"})," function to iterate over the ",(0,s.jsx)(n.code,{children:"fruits"})," array and render each fruit as a ",(0,s.jsx)(n.code,{children:"<li>"})," element."]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"potential-issues-with-improper-keys",children:"Potential Issues with Improper Keys"}),"\n",(0,s.jsx)(n.p,{children:"If you use non-unique keys or change the keys inappropriately, React might behave unexpectedly. Here's an example that demonstrates a common mistake:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-jsx",children:"import React from 'react';\n\nfunction FruitListWithIndexKey() {\n  const fruits = ['Apple', 'Banana', 'Cherry'];\n\n  return (\n    <ul>\n      {fruits.map((fruit, index) => (\n        <li key={index}>\n          {fruit}\n        </li>\n      ))}\n    </ul>\n  );\n}\n\nexport default FruitListWithIndexKey;\n"})}),"\n",(0,s.jsx)(n.h3,{id:"whats-wrong-here",children:"What's Wrong Here?"}),"\n",(0,s.jsx)(n.p,{children:"In the example above, the index of each item is used as the key. This works fine if the list never changes. However, if the order of items changes (e.g., due to sorting or filtering), React might mix up the items because it relies on the index as the key. This can result in incorrect rendering, such as displaying the wrong item in the wrong position."}),"\n",(0,s.jsx)(n.h2,{id:"best-practices-for-using-keys",children:"Best Practices for Using Keys"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Use Unique Identifiers:"})," Always prefer to use a unique attribute from your data as the key (like ",(0,s.jsx)(n.code,{children:"id"}),"). If your data doesn\u2019t have a unique identifier, consider adding one."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Avoid Using Indexes as Keys:"})," Indexes are not stable in cases where the order of elements might change. Use indices only as a last resort when no other unique identifiers are available, and when you are certain the list order won't change."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Consistency is Key:"})," Ensure that the key remains consistent across renders. If a key changes between renders, React will assume it's a different element, which can cause unnecessary re-renders and performance degradation."]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"further-reading",children:"Further Reading"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.strong,{children:"React Reconciliation"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.strong,{children:"React Lists and Keys Documentation"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.strong,{children:"Common Performance Pitfalls in React"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.strong,{children:"Unique Identifier Generation Strategies in JavaScript"})}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,s.jsx)(n.p,{children:"Keys are an essential tool in React for identifying elements within a list, allowing efficient updates and reordering. Always use unique and consistent keys to avoid rendering issues and to optimize performance. Avoid using indexes as keys unless absolutely necessary and the order of items will not change. Proper use of keys ensures that React can accurately manage the virtual DOM, leading to smoother and more reliable user interfaces."})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>a,x:()=>o});var s=i(6540);const t={},r=s.createContext(t);function a(e){const n=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:a(e.components),s.createElement(r.Provider,{value:n},e.children)}}}]);