"use strict";(self.webpackChunkdocubook=self.webpackChunkdocubook||[]).push([[4400],{8159:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>r,metadata:()=>i,toc:()=>d});var o=t(4848),s=t(8453);const r={},a="useImperativeHandle",i={id:"Hook/7-8-useImperativeHandle",title:"useImperativeHandle",description:"The useImperativeHandle hook is one of the more advanced hooks in React. It allows you to customize the instance value that is exposed to parent components when using ref. This hook is particularly useful when you want to control the behavior or interface of a component in a way that isn't possible through normal props and state management.",source:"@site/docs/7-Hook/7-8-useImperativeHandle.md",sourceDirName:"7-Hook",slug:"/Hook/7-8-useImperativeHandle",permalink:"/Hook/7-8-useImperativeHandle",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Differences Between useLayoutEffect and useEffect",permalink:"/Hook/7-7-Differences Between useLayoutEffect and useEffect"},next:{title:"Custom Hooks",permalink:"/Hook/7-9-Custom Hooks"}},c={},d=[{value:"Understanding <code>useImperativeHandle</code>",id:"understanding-useimperativehandle",level:2},{value:"Basic Syntax",id:"basic-syntax",level:3},{value:"Example: Customizing a Component&#39;s Ref Interface",id:"example-customizing-a-components-ref-interface",level:3},{value:"Explanation of the Example",id:"explanation-of-the-example",level:3},{value:"Key Points to Remember",id:"key-points-to-remember",level:3},{value:"Further Reading",id:"further-reading",level:2},{value:"Summary",id:"summary",level:2}];function l(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.h1,{id:"useimperativehandle",children:"useImperativeHandle"}),"\n",(0,o.jsxs)(n.p,{children:["The ",(0,o.jsx)(n.code,{children:"useImperativeHandle"})," hook is one of the more advanced hooks in React. It allows you to customize the instance value that is exposed to parent components when using ",(0,o.jsx)(n.code,{children:"ref"}),". This hook is particularly useful when you want to control the behavior or interface of a component in a way that isn't possible through normal props and state management."]}),"\n",(0,o.jsxs)(n.h2,{id:"understanding-useimperativehandle",children:["Understanding ",(0,o.jsx)(n.code,{children:"useImperativeHandle"})]}),"\n",(0,o.jsxs)(n.p,{children:["In React, ",(0,o.jsx)(n.code,{children:"ref"})," is a way to directly reference a DOM element or a React component instance. Normally, when you use ",(0,o.jsx)(n.code,{children:"ref"}),", you get a reference to the underlying DOM element. However, sometimes you need to expose a more complex or specific interface, beyond what the DOM element itself provides. This is where ",(0,o.jsx)(n.code,{children:"useImperativeHandle"})," comes in."]}),"\n",(0,o.jsx)(n.h3,{id:"basic-syntax",children:"Basic Syntax"}),"\n",(0,o.jsxs)(n.p,{children:["The basic syntax for ",(0,o.jsx)(n.code,{children:"useImperativeHandle"})," is as follows:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-javascript",children:"useImperativeHandle(ref, () => ({\n  // methods and properties to expose\n}), [dependencies]);\n"})}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:(0,o.jsx)(n.code,{children:"ref"})}),": The ref object passed from the parent component."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:(0,o.jsx)(n.code,{children:"() => ({ ... })"})}),": A function that returns an object. This object contains the methods or properties you want to expose to the parent."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:(0,o.jsx)(n.code,{children:"[dependencies]"})}),": An optional array of dependencies. If any dependency changes, the object returned by the function will be recalculated."]}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"example-customizing-a-components-ref-interface",children:"Example: Customizing a Component's Ref Interface"}),"\n",(0,o.jsxs)(n.p,{children:["Let's explore a concrete example where ",(0,o.jsx)(n.code,{children:"useImperativeHandle"})," is useful. Imagine you have a ",(0,o.jsx)(n.code,{children:"CustomInput"})," component that you want to expose a method to focus the input from its parent component."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-javascript",children:"import React, { useRef, useImperativeHandle, forwardRef } from 'react';\n\n// A simple input component wrapped in forwardRef to use useImperativeHandle\nconst CustomInput = forwardRef((props, ref) => {\n  const inputRef = useRef();\n\n  useImperativeHandle(ref, () => ({\n    focus: () => {\n      // Custom focus method\n      inputRef.current.focus();\n    },\n    clear: () => {\n      // Custom clear method\n      inputRef.current.value = '';\n    }\n  }));\n\n  return (\n    <input\n      ref={inputRef}\n      type=\"text\"\n      placeholder=\"Enter some text\"\n    />\n  );\n});\n\n// Parent component using the CustomInput component\nfunction ParentComponent() {\n  const customInputRef = useRef();\n\n  const handleFocus = () => {\n    // Calling the custom focus method exposed by useImperativeHandle\n    customInputRef.current.focus();\n  };\n\n  const handleClear = () => {\n    // Calling the custom clear method exposed by useImperativeHandle\n    customInputRef.current.clear();\n  };\n\n  return (\n    <div>\n      <CustomInput ref={customInputRef} />\n      <button onClick={handleFocus}>Focus Input</button>\n      <button onClick={handleClear}>Clear Input</button>\n    </div>\n  );\n}\n\nexport default ParentComponent;\n"})}),"\n",(0,o.jsx)(n.h3,{id:"explanation-of-the-example",children:"Explanation of the Example"}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:(0,o.jsx)(n.code,{children:"forwardRef"})}),": We use ",(0,o.jsx)(n.code,{children:"forwardRef"})," to pass the ",(0,o.jsx)(n.code,{children:"ref"})," from the parent (",(0,o.jsx)(n.code,{children:"ParentComponent"}),") to the child (",(0,o.jsx)(n.code,{children:"CustomInput"}),"). This is essential when using ",(0,o.jsx)(n.code,{children:"useImperativeHandle"})," because it allows the parent to interact with the child's internal methods."]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:(0,o.jsx)(n.code,{children:"useImperativeHandle"})}),": Inside ",(0,o.jsx)(n.code,{children:"CustomInput"}),", ",(0,o.jsx)(n.code,{children:"useImperativeHandle"})," is used to expose a custom interface (in this case, the ",(0,o.jsx)(n.code,{children:"focus"})," and ",(0,o.jsx)(n.code,{children:"clear"})," methods). These methods provide specific functionalities that the parent component can invoke."]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Parent Interaction"}),": In the parent component, we create a ref (",(0,o.jsx)(n.code,{children:"customInputRef"}),") and pass it to ",(0,o.jsx)(n.code,{children:"CustomInput"}),". We then use this ref to call the ",(0,o.jsx)(n.code,{children:"focus"})," and ",(0,o.jsx)(n.code,{children:"clear"})," methods, demonstrating how ",(0,o.jsx)(n.code,{children:"useImperativeHandle"})," enables the parent to perform specific actions on the child component."]}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"key-points-to-remember",children:"Key Points to Remember"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"When to Use"}),": ",(0,o.jsx)(n.code,{children:"useImperativeHandle"})," should be used sparingly and only when you need to expose methods or properties that are not easily managed through props and state."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Forwarding Refs"}),": Always use ",(0,o.jsx)(n.code,{children:"forwardRef"})," with ",(0,o.jsx)(n.code,{children:"useImperativeHandle"})," to ensure that the ref passed from the parent is correctly handled."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Dependency Array"}),": Like with other hooks, the dependency array ensures that the exposed methods are only recalculated when necessary, optimizing performance."]}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"further-reading",children:"Further Reading"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.strong,{children:"Refs in React"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.strong,{children:"React's forwardRef Function"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.strong,{children:"Managing Focus in React"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.strong,{children:"Advanced Hooks in React"})}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.code,{children:"useImperativeHandle"})," is a powerful React hook that allows you to customize what a parent component can do with a child's ref. By exposing specific methods or properties, you can provide more controlled and predictable interactions between components. This hook is best used when you need fine-grained control over a component's behavior that goes beyond what can be achieved with props and state alone."]})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(l,{...e})}):l(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>i});var o=t(6540);const s={},r=o.createContext(s);function a(e){const n=o.useContext(r);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),o.createElement(r.Provider,{value:n},e.children)}}}]);