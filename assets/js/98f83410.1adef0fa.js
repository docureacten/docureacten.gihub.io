"use strict";(self.webpackChunkdocubook=self.webpackChunkdocubook||[]).push([[372],{988:(e,o,n)=>{n.r(o),n.d(o,{assets:()=>a,contentTitle:()=>r,default:()=>h,frontMatter:()=>i,metadata:()=>c,toc:()=>l});var t=n(4848),s=n(8453);const i={},r="Custom Hooks",c={id:"Hook/7-9-Custom Hooks",title:"Custom Hooks",description:"React's custom hooks are a powerful tool that allows developers to extract and reuse stateful logic across different components. By understanding and utilizing custom hooks, you can make your code more modular, readable, and maintainable. In this section, we'll explore what custom hooks are, how to create them, and best practices for their use.",source:"@site/docs/7-Hook/7-9-Custom Hooks.md",sourceDirName:"7-Hook",slug:"/Hook/7-9-Custom Hooks",permalink:"/Hook/7-9-Custom Hooks",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"useImperativeHandle",permalink:"/Hook/7-8-useImperativeHandle"},next:{title:"Techniques for Optimizing Component Performance",permalink:"/Optimization/8-1-Techniques for Optimizing Component Performance"}},a={},l=[{value:"What Are Custom Hooks?",id:"what-are-custom-hooks",level:2},{value:"Key Points to Remember",id:"key-points-to-remember",level:3},{value:"Creating a Custom Hook",id:"creating-a-custom-hook",level:2},{value:"Code Example: <code>useCounter</code> Hook",id:"code-example-usecounter-hook",level:3},{value:"Using <code>useCounter</code> in a Component",id:"using-usecounter-in-a-component",level:3},{value:"Best Practices for Custom Hooks",id:"best-practices-for-custom-hooks",level:2},{value:"When to Use Custom Hooks",id:"when-to-use-custom-hooks",level:2},{value:"Further Reading",id:"further-reading",level:2},{value:"Summary",id:"summary",level:2}];function u(e){const o={code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(o.h1,{id:"custom-hooks",children:"Custom Hooks"}),"\n",(0,t.jsxs)(o.p,{children:["React's ",(0,t.jsx)(o.strong,{children:"custom hooks"})," are a powerful tool that allows developers to extract and reuse stateful logic across different components. By understanding and utilizing custom hooks, you can make your code more modular, readable, and maintainable. In this section, we'll explore what custom hooks are, how to create them, and best practices for their use."]}),"\n",(0,t.jsx)(o.h2,{id:"what-are-custom-hooks",children:"What Are Custom Hooks?"}),"\n",(0,t.jsxs)(o.p,{children:["Custom hooks are simply JavaScript functions that start with the word ",(0,t.jsx)(o.code,{children:"use"})," and allow you to extract and reuse stateful logic in your components. They leverage React's existing hooks like ",(0,t.jsx)(o.code,{children:"useState"}),", ",(0,t.jsx)(o.code,{children:"useEffect"}),", ",(0,t.jsx)(o.code,{children:"useRef"}),", and others. The main advantage of custom hooks is that they encapsulate logic, making it easy to share between components without duplicating code."]}),"\n",(0,t.jsx)(o.h3,{id:"key-points-to-remember",children:"Key Points to Remember"}),"\n",(0,t.jsxs)(o.ul,{children:["\n",(0,t.jsxs)(o.li,{children:[(0,t.jsx)(o.strong,{children:"Naming Convention"}),": Always start the function name with ",(0,t.jsx)(o.code,{children:"use"}),". This is a convention React uses to identify these functions as hooks."]}),"\n",(0,t.jsxs)(o.li,{children:[(0,t.jsx)(o.strong,{children:"State and Side Effects"}),": Custom hooks can manage state (",(0,t.jsx)(o.code,{children:"useState"}),") and handle side effects (",(0,t.jsx)(o.code,{children:"useEffect"}),"), just like any other hook."]}),"\n",(0,t.jsxs)(o.li,{children:[(0,t.jsx)(o.strong,{children:"Pure Functions"}),": Custom hooks should ideally be pure functions, meaning they don't modify any external state or variables directly, which helps in keeping the logic predictable and testable."]}),"\n"]}),"\n",(0,t.jsx)(o.h2,{id:"creating-a-custom-hook",children:"Creating a Custom Hook"}),"\n",(0,t.jsxs)(o.p,{children:["Let's create a custom hook called ",(0,t.jsx)(o.code,{children:"useCounter"})," that manages a simple counter state. This hook will provide functionalities to increment, decrement, and reset the counter."]}),"\n",(0,t.jsxs)(o.h3,{id:"code-example-usecounter-hook",children:["Code Example: ",(0,t.jsx)(o.code,{children:"useCounter"})," Hook"]}),"\n",(0,t.jsx)(o.pre,{children:(0,t.jsx)(o.code,{className:"language-javascript",children:"// Custom hook: useCounter\nimport { useState } from 'react';\n\nfunction useCounter(initialValue = 0) {\n  // Initialize the state with the initialValue\n  const [count, setCount] = useState(initialValue);\n\n  // Function to increment the count\n  const increment = () => setCount(count + 1);\n\n  // Function to decrement the count\n  const decrement = () => setCount(count - 1);\n\n  // Function to reset the count to the initial value\n  const reset = () => setCount(initialValue);\n\n  // Return the current count and the functions to manipulate it\n  return { count, increment, decrement, reset };\n}\n"})}),"\n",(0,t.jsxs)(o.h3,{id:"using-usecounter-in-a-component",children:["Using ",(0,t.jsx)(o.code,{children:"useCounter"})," in a Component"]}),"\n",(0,t.jsx)(o.p,{children:"Now, let's see how this custom hook can be utilized in a functional component."}),"\n",(0,t.jsx)(o.pre,{children:(0,t.jsx)(o.code,{className:"language-javascript",children:"import React from 'react';\nimport useCounter from './useCounter'; // Assuming the hook is in the same directory\n\nfunction CounterComponent() {\n  // Use the custom hook to get the count and control functions\n  const { count, increment, decrement, reset } = useCounter(10); // Start the counter at 10\n\n  return (\n    <div>\n      <h2>Counter: {count}</h2>\n      <button onClick={increment}>Increment</button>\n      <button onClick={decrement}>Decrement</button>\n      <button onClick={reset}>Reset</button>\n    </div>\n  );\n}\n"})}),"\n",(0,t.jsx)(o.p,{children:"In this example:"}),"\n",(0,t.jsxs)(o.ul,{children:["\n",(0,t.jsxs)(o.li,{children:["We created a custom hook ",(0,t.jsx)(o.code,{children:"useCounter"})," that encapsulates all the logic related to managing a counter."]}),"\n",(0,t.jsxs)(o.li,{children:["The ",(0,t.jsx)(o.code,{children:"CounterComponent"})," uses this hook to manage its state without needing to manually set up the ",(0,t.jsx)(o.code,{children:"useState"})," hook or the corresponding functions."]}),"\n",(0,t.jsx)(o.li,{children:"This approach leads to cleaner and more modular code, as the logic is reusable across multiple components."}),"\n"]}),"\n",(0,t.jsx)(o.h2,{id:"best-practices-for-custom-hooks",children:"Best Practices for Custom Hooks"}),"\n",(0,t.jsxs)(o.ul,{children:["\n",(0,t.jsxs)(o.li,{children:[(0,t.jsx)(o.strong,{children:"Separation of Concerns"}),": Custom hooks should focus on a single responsibility. If your hook is doing too many things, consider breaking it down into smaller hooks."]}),"\n",(0,t.jsxs)(o.li,{children:[(0,t.jsx)(o.strong,{children:"Reusability"}),": Strive to make your custom hooks reusable across different parts of your application."]}),"\n",(0,t.jsxs)(o.li,{children:[(0,t.jsx)(o.strong,{children:"Encapsulation"}),": Keep the implementation details hidden. Only expose what is necessary for the components using the hook."]}),"\n",(0,t.jsxs)(o.li,{children:[(0,t.jsx)(o.strong,{children:"Naming"}),": Use meaningful names that clearly indicate what the hook does, following the ",(0,t.jsx)(o.code,{children:"use"})," prefix convention."]}),"\n"]}),"\n",(0,t.jsx)(o.h2,{id:"when-to-use-custom-hooks",children:"When to Use Custom Hooks"}),"\n",(0,t.jsx)(o.p,{children:"Custom hooks are particularly useful in the following scenarios:"}),"\n",(0,t.jsxs)(o.ul,{children:["\n",(0,t.jsxs)(o.li,{children:[(0,t.jsx)(o.strong,{children:"Shared Logic"}),": When you have logic that needs to be shared across multiple components."]}),"\n",(0,t.jsxs)(o.li,{children:[(0,t.jsx)(o.strong,{children:"Complex Components"}),": When a component\u2019s logic becomes too complex, custom hooks can help break it down into manageable pieces."]}),"\n",(0,t.jsxs)(o.li,{children:[(0,t.jsx)(o.strong,{children:"Repetitive Code"}),": When you find yourself copying and pasting the same logic in different components, it\u2019s a good indicator that a custom hook might be beneficial."]}),"\n"]}),"\n",(0,t.jsx)(o.h2,{id:"further-reading",children:"Further Reading"}),"\n",(0,t.jsxs)(o.ul,{children:["\n",(0,t.jsx)(o.li,{children:(0,t.jsx)(o.strong,{children:"React Hooks"})}),"\n",(0,t.jsx)(o.li,{children:(0,t.jsx)(o.strong,{children:"useState and useEffect"})}),"\n",(0,t.jsx)(o.li,{children:(0,t.jsx)(o.strong,{children:"Encapsulating Logic with Custom Hooks"})}),"\n",(0,t.jsx)(o.li,{children:(0,t.jsx)(o.strong,{children:"Best Practices for React Hooks"})}),"\n"]}),"\n",(0,t.jsx)(o.h2,{id:"summary",children:"Summary"}),"\n",(0,t.jsx)(o.p,{children:"Custom hooks in React are a powerful way to extract and reuse stateful logic across components, improving code modularity and maintainability. By adhering to best practices like proper naming, encapsulation, and focusing on single responsibilities, you can create custom hooks that make your codebase cleaner and more efficient. In this section, we explored what custom hooks are, how to create them, and when they should be used, along with a concrete example to solidify these concepts."})]})}function h(e={}){const{wrapper:o}={...(0,s.R)(),...e.components};return o?(0,t.jsx)(o,{...e,children:(0,t.jsx)(u,{...e})}):u(e)}},8453:(e,o,n)=>{n.d(o,{R:()=>r,x:()=>c});var t=n(6540);const s={},i=t.createContext(s);function r(e){const o=t.useContext(i);return t.useMemo((function(){return"function"==typeof e?e(o):{...o,...e}}),[o,e])}function c(e){let o;return o=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),t.createElement(i.Provider,{value:o},e.children)}}}]);