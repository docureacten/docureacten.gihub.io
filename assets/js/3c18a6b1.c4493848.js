"use strict";(self.webpackChunkdocubook=self.webpackChunkdocubook||[]).push([[6916],{8530:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>a,contentTitle:()=>c,default:()=>f,frontMatter:()=>i,metadata:()=>r,toc:()=>d});var s=t(4848),o=t(8453);const i={},c="Differences Between useLayoutEffect and useEffect",r={id:"Hook/7-7-Differences Between useLayoutEffect and useEffect",title:"Differences Between useLayoutEffect and useEffect",description:"In React, two important hooks that manage side effects are useEffect and useLayoutEffect. While they might seem similar at first glance, they serve distinct purposes and are triggered at different points in the rendering process. Understanding the differences between these two hooks is essential for optimizing your React applications and ensuring that your components behave as expected.",source:"@site/docs/7-Hook/7-7-Differences Between useLayoutEffect and useEffect.md",sourceDirName:"7-Hook",slug:"/Hook/7-7-Differences Between useLayoutEffect and useEffect",permalink:"/Hook/7-7-Differences Between useLayoutEffect and useEffect",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"useLayoutEffect",permalink:"/Hook/7-6-useLayoutEffect"},next:{title:"useImperativeHandle",permalink:"/Hook/7-8-useImperativeHandle"}},a={},d=[{value:"Understanding <code>useEffect</code>",id:"understanding-useeffect",level:2},{value:"Example of <code>useEffect</code>",id:"example-of-useeffect",level:3},{value:"Key Points about <code>useEffect</code>",id:"key-points-about-useeffect",level:3},{value:"Understanding <code>useLayoutEffect</code>",id:"understanding-uselayouteffect",level:2},{value:"Example of <code>useLayoutEffect</code>",id:"example-of-uselayouteffect",level:3},{value:"Key Points about <code>useLayoutEffect</code>",id:"key-points-about-uselayouteffect",level:3},{value:"When to Use Which Hook",id:"when-to-use-which-hook",level:2},{value:"Further Reading",id:"further-reading",level:2},{value:"Summary",id:"summary",level:2}];function u(e){const n={code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h1,{id:"differences-between-uselayouteffect-and-useeffect",children:"Differences Between useLayoutEffect and useEffect"}),"\n",(0,s.jsxs)(n.p,{children:["In React, two important hooks that manage side effects are ",(0,s.jsx)(n.code,{children:"useEffect"})," and ",(0,s.jsx)(n.code,{children:"useLayoutEffect"}),". While they might seem similar at first glance, they serve distinct purposes and are triggered at different points in the rendering process. Understanding the differences between these two hooks is essential for optimizing your React applications and ensuring that your components behave as expected."]}),"\n",(0,s.jsxs)(n.h2,{id:"understanding-useeffect",children:["Understanding ",(0,s.jsx)(n.code,{children:"useEffect"})]}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"useEffect"})," hook is designed to handle side effects in functional components. Side effects include actions like fetching data, updating the DOM, setting up subscriptions, or manually changing the state."]}),"\n",(0,s.jsxs)(n.h3,{id:"example-of-useeffect",children:["Example of ",(0,s.jsx)(n.code,{children:"useEffect"})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"import React, { useState, useEffect } from 'react';\n\nfunction ExampleComponent() {\n  const [count, setCount] = useState(0);\n\n  // useEffect is called after the component renders\n  useEffect(() => {\n    document.title = `You clicked ${count} times`;\n\n    // Cleanup function is optional, but it's a good practice to include it\n    return () => {\n      console.log('Cleanup on component unmount or before the next effect');\n    };\n  }, [count]); // Only re-run the effect if count changes\n\n  return (\n    <div>\n      <p>You clicked {count} times</p>\n      <button onClick={() => setCount(count + 1)}>\n        Click me\n      </button>\n    </div>\n  );\n}\n"})}),"\n",(0,s.jsxs)(n.h3,{id:"key-points-about-useeffect",children:["Key Points about ",(0,s.jsx)(n.code,{children:"useEffect"})]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Timing"}),": ",(0,s.jsx)(n.code,{children:"useEffect"})," runs after the browser paints the screen. This means that the effect runs ",(0,s.jsx)(n.em,{children:"after"})," the DOM has been updated and displayed to the user. This timing is ideal for operations that don't block the browser's rendering, like logging, network requests, or updating non-visible elements."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Non-blocking"}),": Because ",(0,s.jsx)(n.code,{children:"useEffect"})," runs asynchronously after the paint, it does not block the rendering process. This ensures a smoother user experience, especially in more complex or slower components."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Dependency Array"}),": The dependency array controls when the effect runs. An empty array (",(0,s.jsx)(n.code,{children:"[]"}),") means the effect runs only once (on mount and unmount). If you provide dependencies, the effect runs every time those dependencies change."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.h2,{id:"understanding-uselayouteffect",children:["Understanding ",(0,s.jsx)(n.code,{children:"useLayoutEffect"})]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"useLayoutEffect"})," is similar to ",(0,s.jsx)(n.code,{children:"useEffect"})," in terms of syntax but differs in when it is executed. It is run synchronously after all DOM mutations but before the browser has a chance to paint. This makes ",(0,s.jsx)(n.code,{children:"useLayoutEffect"})," suitable for actions that need to happen before the screen is updated."]}),"\n",(0,s.jsxs)(n.h3,{id:"example-of-uselayouteffect",children:["Example of ",(0,s.jsx)(n.code,{children:"useLayoutEffect"})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"import React, { useState, useLayoutEffect, useRef } from 'react';\n\nfunction LayoutEffectExample() {\n  const [size, setSize] = useState({ width: 0, height: 0 });\n  const boxRef = useRef();\n\n  // useLayoutEffect runs before the browser paints the screen\n  useLayoutEffect(() => {\n    const box = boxRef.current;\n    setSize({\n      width: box.offsetWidth,\n      height: box.offsetHeight\n    });\n    console.log('Size calculated before paint:', size);\n  });\n\n  return (\n    <div>\n      <div ref={boxRef} style={{ width: '100px', height: '100px', backgroundColor: 'lightblue' }}>\n        Box\n      </div>\n      <p>Box dimensions: {size.width} x {size.height}</p>\n    </div>\n  );\n}\n"})}),"\n",(0,s.jsxs)(n.h3,{id:"key-points-about-uselayouteffect",children:["Key Points about ",(0,s.jsx)(n.code,{children:"useLayoutEffect"})]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Timing"}),": ",(0,s.jsx)(n.code,{children:"useLayoutEffect"})," is executed after the DOM has been updated but ",(0,s.jsx)(n.em,{children:"before"})," the browser paints the screen. This ensures that any DOM measurements or manipulations are applied immediately and before the user sees the content."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Blocking"}),": Since it runs synchronously, ",(0,s.jsx)(n.code,{children:"useLayoutEffect"})," can block the browser's paint. This can cause delays in rendering if the operations inside the hook are time-consuming. Therefore, it's crucial to keep the logic inside ",(0,s.jsx)(n.code,{children:"useLayoutEffect"})," quick and efficient."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Use Case"}),": ",(0,s.jsx)(n.code,{children:"useLayoutEffect"})," is primarily used when you need to perform side effects that can affect the layout of your component, such as measuring the DOM or synchronously manipulating elements. For most other side effects, ",(0,s.jsx)(n.code,{children:"useEffect"})," is preferred due to its non-blocking nature."]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"when-to-use-which-hook",children:"When to Use Which Hook"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsxs)(n.strong,{children:["Use ",(0,s.jsx)(n.code,{children:"useEffect"})]}),": For most side effects, especially those that don't impact the layout, such as fetching data, setting up subscriptions, or logging. It ensures that the UI is painted as soon as possible, improving perceived performance."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsxs)(n.strong,{children:["Use ",(0,s.jsx)(n.code,{children:"useLayoutEffect"})]}),": When you need to read layout properties or perform synchronous updates that must occur before the browser paints. Examples include measuring an element's size or applying styles that must reflect immediately before the user sees the content."]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"further-reading",children:"Further Reading"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"React hooks"}),"\n",(0,s.jsx)(n.li,{children:"Side effects in React"}),"\n",(0,s.jsx)(n.li,{children:"Performance optimization in React"}),"\n",(0,s.jsx)(n.li,{children:"React rendering process"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,s.jsxs)(n.p,{children:["The primary difference between ",(0,s.jsx)(n.code,{children:"useEffect"})," and ",(0,s.jsx)(n.code,{children:"useLayoutEffect"})," lies in their timing and impact on the rendering process. ",(0,s.jsx)(n.code,{children:"useEffect"})," runs after the paint and is non-blocking, making it suitable for most side effects. ",(0,s.jsx)(n.code,{children:"useLayoutEffect"}),", on the other hand, runs before the paint and is blocking, which makes it ideal for effects that directly impact the layout or measurements of the DOM. Understanding these differences allows you to choose the appropriate hook for your specific needs, optimizing both performance and user experience."]})]})}function f(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(u,{...e})}):u(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>c,x:()=>r});var s=t(6540);const o={},i=s.createContext(o);function c(e){const n=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:c(e.components),s.createElement(i.Provider,{value:n},e.children)}}}]);