"use strict";(self.webpackChunkdocubook=self.webpackChunkdocubook||[]).push([[2416],{7148:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>r,default:()=>u,frontMatter:()=>o,metadata:()=>a,toc:()=>l});var s=t(4848),i=t(8453);const o={},r="Reviewing useState, useRef, and useEffect",a={id:"Hook/7-1-Reviewing useState, useRef, and useEffect",title:"Reviewing useState, useRef, and useEffect",description:"When working with React, three hooks you'll frequently encounter are useState, useRef, and useEffect. These hooks are essential for managing state, referencing DOM elements or values, and handling side effects in functional components. In this section, we'll review how each of these hooks works, with concrete examples to deepen your understanding.",source:"@site/docs/7-Hook/7-1-Reviewing useState, useRef, and useEffect.md",sourceDirName:"7-Hook",slug:"/Hook/7-1-Reviewing useState, useRef, and useEffect",permalink:"/Hook/7-1-Reviewing useState, useRef, and useEffect",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Dynamic Rendering and Conditional Rendering",permalink:"/Rendering/6-5-Dynamic Rendering and Conditional Rendering"},next:{title:"Types of Custom Hook Returns",permalink:"/Hook/7-10-Types of Custom Hook Returns"}},c={},l=[{value:"1. <code>useState</code>: Managing Component State",id:"1-usestate-managing-component-state",level:2},{value:"Example:",id:"example",level:3},{value:"Explanation:",id:"explanation",level:3},{value:"Key Points:",id:"key-points",level:3},{value:"2. <code>useRef</code>: Accessing DOM Elements and Storing Persistent Values",id:"2-useref-accessing-dom-elements-and-storing-persistent-values",level:2},{value:"Example 1: Accessing DOM Elements",id:"example-1-accessing-dom-elements",level:3},{value:"Example 2: Storing Persistent Values",id:"example-2-storing-persistent-values",level:3},{value:"Explanation:",id:"explanation-1",level:3},{value:"Key Points:",id:"key-points-1",level:3},{value:"3. <code>useEffect</code>: Handling Side Effects",id:"3-useeffect-handling-side-effects",level:2},{value:"Example: Fetching Data",id:"example-fetching-data",level:3},{value:"Explanation:",id:"explanation-2",level:3},{value:"Key Points:",id:"key-points-2",level:3},{value:"Further Reading",id:"further-reading",level:2},{value:"Summary",id:"summary",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h1,{id:"reviewing-usestate-useref-and-useeffect",children:"Reviewing useState, useRef, and useEffect"}),"\n",(0,s.jsxs)(n.p,{children:["When working with React, three hooks you'll frequently encounter are ",(0,s.jsx)(n.code,{children:"useState"}),", ",(0,s.jsx)(n.code,{children:"useRef"}),", and ",(0,s.jsx)(n.code,{children:"useEffect"}),". These hooks are essential for managing state, referencing DOM elements or values, and handling side effects in functional components. In this section, we'll review how each of these hooks works, with concrete examples to deepen your understanding."]}),"\n",(0,s.jsxs)(n.h2,{id:"1-usestate-managing-component-state",children:["1. ",(0,s.jsx)(n.code,{children:"useState"}),": Managing Component State"]}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"useState"})," hook is used to manage state within a functional component. It allows you to add local state to a component, which React will keep track of between renders."]}),"\n",(0,s.jsx)(n.h3,{id:"example",children:"Example:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"import React, { useState } from 'react';\n\nfunction Counter() {\n  // Initialize the state with a value of 0\n  const [count, setCount] = useState(0);\n\n  // Function to increment the count\n  const incrementCount = () => {\n    setCount(count + 1);\n  };\n\n  return (\n    <div>\n      <p>Current count: {count}</p>\n      {/* Button to trigger the increment */}\n      <button onClick={incrementCount}>Increment</button>\n    </div>\n  );\n}\n\nexport default Counter;\n"})}),"\n",(0,s.jsx)(n.h3,{id:"explanation",children:"Explanation:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"State Initialization:"})," ",(0,s.jsx)(n.code,{children:"useState(0)"})," initializes ",(0,s.jsx)(n.code,{children:"count"})," with a value of ",(0,s.jsx)(n.code,{children:"0"}),". The hook returns an array with the current state value and a function to update it (",(0,s.jsx)(n.code,{children:"setCount"}),")."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"State Update:"})," The ",(0,s.jsx)(n.code,{children:"incrementCount"})," function updates the state by calling ",(0,s.jsx)(n.code,{children:"setCount(count + 1)"}),", which tells React to re-render the component with the new count value."]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"key-points",children:"Key Points:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"State Persistence:"})," React preserves the state between renders."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Rerendering:"})," Calling the state update function (",(0,s.jsx)(n.code,{children:"setCount"}),") triggers a re-render of the component."]}),"\n"]}),"\n",(0,s.jsxs)(n.h2,{id:"2-useref-accessing-dom-elements-and-storing-persistent-values",children:["2. ",(0,s.jsx)(n.code,{children:"useRef"}),": Accessing DOM Elements and Storing Persistent Values"]}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"useRef"})," hook provides a way to access DOM elements directly or to store a mutable value that persists across renders without causing a re-render."]}),"\n",(0,s.jsx)(n.h3,{id:"example-1-accessing-dom-elements",children:"Example 1: Accessing DOM Elements"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'import React, { useRef } from \'react\';\n\nfunction FocusInput() {\n  // Create a ref to store the input element\n  const inputRef = useRef(null);\n\n  // Function to focus the input field\n  const focusInputField = () => {\n    inputRef.current.focus();\n  };\n\n  return (\n    <div>\n      {/* Attach the ref to the input element */}\n      <input ref={inputRef} type="text" placeholder="Click the button to focus" />\n      {/* Button to trigger the focus */}\n      <button onClick={focusInputField}>Focus Input</button>\n    </div>\n  );\n}\n\nexport default FocusInput;\n'})}),"\n",(0,s.jsx)(n.h3,{id:"example-2-storing-persistent-values",children:"Example 2: Storing Persistent Values"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"import React, { useState, useRef } from 'react';\n\nfunction Stopwatch() {\n  const [time, setTime] = useState(0);\n  const timerIdRef = useRef(null);\n\n  const startTimer = () => {\n    timerIdRef.current = setInterval(() => {\n      setTime(prevTime => prevTime + 1);\n    }, 1000);\n  };\n\n  const stopTimer = () => {\n    clearInterval(timerIdRef.current);\n  };\n\n  return (\n    <div>\n      <p>Elapsed time: {time} seconds</p>\n      <button onClick={startTimer}>Start</button>\n      <button onClick={stopTimer}>Stop</button>\n    </div>\n  );\n}\n\nexport default Stopwatch;\n"})}),"\n",(0,s.jsx)(n.h3,{id:"explanation-1",children:"Explanation:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"DOM Access:"})," In the first example, ",(0,s.jsx)(n.code,{children:"useRef"})," is used to create a reference to the input field, allowing direct manipulation of the DOM element."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Persistent Values:"})," In the second example, ",(0,s.jsx)(n.code,{children:"useRef"})," stores the timer ID, which remains stable across renders. This allows the timer to be stopped without causing unnecessary re-renders."]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"key-points-1",children:"Key Points:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"No Re-renders:"})," Modifying a ",(0,s.jsx)(n.code,{children:"useRef"})," value does not cause the component to re-render."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"DOM Manipulation:"})," ",(0,s.jsx)(n.code,{children:"useRef"})," is commonly used for accessing and interacting with DOM elements."]}),"\n"]}),"\n",(0,s.jsxs)(n.h2,{id:"3-useeffect-handling-side-effects",children:["3. ",(0,s.jsx)(n.code,{children:"useEffect"}),": Handling Side Effects"]}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"useEffect"})," hook is crucial for performing side effects in your components, such as fetching data, subscribing to events, or directly manipulating the DOM. It runs after the component renders, ensuring that your side effect logic doesn't block the initial render."]}),"\n",(0,s.jsx)(n.h3,{id:"example-fetching-data",children:"Example: Fetching Data"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"import React, { useState, useEffect } from 'react';\n\nfunction DataFetcher() {\n  const [data, setData] = useState(null);\n\n  useEffect(() => {\n    // Fetch data from an API\n    fetch('https://jsonplaceholder.typicode.com/posts/1')\n      .then(response => response.json())\n      .then(json => setData(json));\n\n    // Cleanup function (optional) - could be used for cleanup tasks like unsubscribing from a service\n    return () => {\n      console.log('Cleanup if necessary');\n    };\n  }, []); // Empty dependency array means this effect runs once after initial render\n\n  return (\n    <div>\n      <h1>Fetched Data:</h1>\n      {/* Display the fetched data */}\n      {data ? <pre>{JSON.stringify(data, null, 2)}</pre> : 'Loading...'}\n    </div>\n  );\n}\n\nexport default DataFetcher;\n"})}),"\n",(0,s.jsx)(n.h3,{id:"explanation-2",children:"Explanation:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Effect Function:"})," The function passed to ",(0,s.jsx)(n.code,{children:"useEffect"})," runs after the component renders. Here, it fetches data from an API and updates the state."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Cleanup:"})," If needed, the cleanup function can handle any necessary cleanup (like unsubscribing from a service) when the component unmounts or before the effect re-runs."]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"key-points-2",children:"Key Points:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Dependencies:"})," The array ",(0,s.jsx)(n.code,{children:"[]"})," tells React to run the effect only once after the initial render. Adding dependencies in the array can trigger the effect when those dependencies change."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Asynchronous Code:"})," Use ",(0,s.jsx)(n.code,{children:"useEffect"})," for managing asynchronous operations to avoid blocking the component's render process."]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"further-reading",children:"Further Reading"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"State Management:"})," Managing state in larger applications, Context API"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Advanced Refs:"})," Using ",(0,s.jsx)(n.code,{children:"useImperativeHandle"})," with ",(0,s.jsx)(n.code,{children:"useRef"})]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Effects:"})," Conditional effects, multiple effects in one component"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,s.jsxs)(n.p,{children:["In this review, we covered three essential React hooks: ",(0,s.jsx)(n.code,{children:"useState"}),", ",(0,s.jsx)(n.code,{children:"useRef"}),", and ",(0,s.jsx)(n.code,{children:"useEffect"}),". These hooks help you manage state, reference DOM elements or persistent values, and handle side effects in your components. Understanding their usage and key concepts is crucial for building interactive and efficient React applications. Remember to use ",(0,s.jsx)(n.code,{children:"useState"})," for managing state, ",(0,s.jsx)(n.code,{children:"useRef"})," for DOM access or persistent values, and ",(0,s.jsx)(n.code,{children:"useEffect"})," for side effects like data fetching or DOM manipulation."]})]})}function u(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>a});var s=t(6540);const i={},o=s.createContext(i);function r(e){const n=s.useContext(o);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),s.createElement(o.Provider,{value:n},e.children)}}}]);