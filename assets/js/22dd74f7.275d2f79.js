"use strict";(self.webpackChunkdocubook=self.webpackChunkdocubook||[]).push([[1567],{5226:e=>{e.exports=JSON.parse('{"version":{"pluginId":"default","version":"current","label":"Next","banner":null,"badge":false,"noIndex":false,"className":"docs-version-current","isLast":true,"docsSidebars":{"tutorialSidebar":[{"type":"link","label":"Getting Started","href":"/","docId":"index","unlisted":false},{"type":"category","label":"Basic","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"Introduction to React and Setting Up Development Environment","href":"/Basic/1-1-Introduction to React and Setting Up Development Environment","docId":"Basic/1-1-Introduction to React and Setting Up Development Environment","unlisted":false},{"type":"link","label":"Introduction to JSX and Expressing React Components","href":"/Basic/1-2-Introduction to JSX and Expressing React Components","docId":"Basic/1-2-Introduction to JSX and Expressing React Components","unlisted":false},{"type":"link","label":"Why Use Functional Components Instead of Class Components","href":"/Basic/1-3-Why Use Functional Components Instead of Class Components","docId":"Basic/1-3-Why Use Functional Components Instead of Class Components","unlisted":false},{"type":"link","label":"Passing Data to Components with Props","href":"/Basic/1-4-Passing Data to Components with Props","docId":"Basic/1-4-Passing Data to Components with Props","unlisted":false},{"type":"link","label":"Managing State with State","href":"/Basic/1-5-Managing State with State","docId":"Basic/1-5-Managing State with State","unlisted":false},{"type":"link","label":"Handling Component Events","href":"/Basic/1-6-Handling Component Events","docId":"Basic/1-6-Handling Component Events","unlisted":false},{"type":"link","label":"Conditional Rendering and Iteration in JSX","href":"/Basic/1-7-Conditional Rendering and Iteration in JSX","docId":"Basic/1-7-Conditional Rendering and Iteration in JSX","unlisted":false}]},{"type":"category","label":"State","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"Introduction to State and Good State Naming Practices","href":"/State/2-1-Introduction to State and Good State Naming Practices","docId":"State/2-1-Introduction to State and Good State Naming Practices","unlisted":false},{"type":"link","label":"Managing User Input with State","href":"/State/2-2-Managing User Input with State","docId":"State/2-2-Managing User Input with State","unlisted":false},{"type":"link","label":"Setting Appropriate Initial Values and Removing Unnecessary State","href":"/State/2-3-Setting Appropriate Initial Values and Removing Unnecessary State","docId":"State/2-3-Setting Appropriate Initial Values and Removing Unnecessary State","unlisted":false},{"type":"link","label":"Identifying and Solving Issues with Non-updating Values","href":"/State/2-4-Identifying and Solving Issues with Non-updating Values","docId":"State/2-4-Identifying and Solving Issues with Non-updating Values","unlisted":false},{"type":"link","label":"Managing Flag States","href":"/State/2-5-Managing Flag States","docId":"State/2-5-Managing Flag States","unlisted":false},{"type":"link","label":"Simplifying and Structuring Related States","href":"/State/2-6-Simplifying and Structuring Related States","docId":"State/2-6-Simplifying and Structuring Related States","unlisted":false},{"type":"link","label":"Introduction to useRef and Creating Component Variables Instead of useState","href":"/State/2-7-Introduction to useRef and Creating Component Variables Instead of useState","docId":"State/2-7-Introduction to useRef and Creating Component Variables Instead of useState","unlisted":false},{"type":"link","label":"Understanding the Asynchronous Nature of State Update Functions, Utilizing Previous States, and State Resetting","href":"/State/2-8-Understanding the Asynchronous Nature of State Update Functions, Utilizing Previous States, and State Resetting","docId":"State/2-8-Understanding the Asynchronous Nature of State Update Functions, Utilizing Previous States, and State Resetting","unlisted":false}]},{"type":"category","label":"Props","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"Introduction to Props and Good Prop Naming Practices","href":"/Props/3-1-Introduction to Props and Good Prop Naming Practices","docId":"Props/3-1-Introduction to Props and Good Prop Naming Practices","unlisted":false},{"type":"link","label":"Differences Between State and Props","href":"/Props/3-2-Differences Between State and Props","docId":"Props/3-2-Differences Between State and Props","unlisted":false},{"type":"link","label":"Examples of Avoiding Unnecessary Prop Copying and Operations","href":"/Props/3-3-Examples of Avoiding Unnecessary Prop Copying and Operations","docId":"Props/3-3-Examples of Avoiding Unnecessary Prop Copying and Operations","unlisted":false},{"type":"link","label":"Validating Types and Setting Default Values with PropTypes","href":"/Props/3-4-Validating Types and Setting Default Values with PropTypes","docId":"Props/3-4-Validating Types and Setting Default Values with PropTypes","unlisted":false},{"type":"link","label":"Important Points When Using Destructuring Assignment and ...props","href":"/Props/3-5-Important Points When Using Destructuring Assignment and ...props","docId":"Props/3-5-Important Points When Using Destructuring Assignment and ...props","unlisted":false},{"type":"link","label":"How to Use Shorthand Props","href":"/Props/3-6-How to Use Shorthand Props","docId":"Props/3-6-How to Use Shorthand Props","unlisted":false},{"type":"link","label":"Why Complex Props Should Be Split and the Benefits of Simple Props","href":"/Props/3-7-Why Complex Props Should Be Split and the Benefits of Simple Props","docId":"Props/3-7-Why Complex Props Should Be Split and the Benefits of Simple Props","unlisted":false},{"type":"link","label":"defaultProps","href":"/Props/3-9-defaultProps","docId":"Props/3-9-defaultProps","unlisted":false}]},{"type":"category","label":"Life Cycle","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"Introduction to useEffect and Controlling the Life Cycle","href":"/Life Cycle/4-1-Introduction to useEffect and Controlling the Life Cycle","docId":"Life Cycle/4-1-Introduction to useEffect and Controlling the Life Cycle","unlisted":false},{"type":"link","label":"Using useEffect with Named Functions","href":"/Life Cycle/4-2-Using useEffect with Named Functions","docId":"Life Cycle/4-2-Using useEffect with Named Functions","unlisted":false},{"type":"link","label":"Why useEffect Should Perform Only One Task","href":"/Life Cycle/4-3-Why useEffect Should Perform Only One Task","docId":"Life Cycle/4-3-Why useEffect Should Perform Only One Task","unlisted":false},{"type":"link","label":"Managing Asynchronous Operations Inside useEffect","href":"/Life Cycle/4-4-Managing Asynchronous Operations Inside useEffect","docId":"Life Cycle/4-4-Managing Asynchronous Operations Inside useEffect","unlisted":false}]},{"type":"category","label":"Component","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"Introduction to Components and Good Component Naming Practices","href":"/Component/5-1-Introduction to Components and Good Component Naming Practices","docId":"Component/5-1-Introduction to Components and Good Component Naming Practices","unlisted":false},{"type":"link","label":"How to Use Self-Closing Tags","href":"/Component/5-2-How to Use Self-Closing Tags","docId":"Component/5-2-How to Use Self-Closing Tags","unlisted":false},{"type":"link","label":"When and When Not to Use Fragments","href":"/Component/5-3-When and When Not to Use Fragments","docId":"Component/5-3-When and When Not to Use Fragments","unlisted":false},{"type":"link","label":"Returning JSX from Component Functions","href":"/Component/5-4-Returning JSX from Component Functions","docId":"Component/5-4-Returning JSX from Component Functions","unlisted":false},{"type":"link","label":"Declaring Inner Components Within Components","href":"/Component/5-5-Declaring Inner Components Within Components","docId":"Component/5-5-Declaring Inner Components Within Components","unlisted":false},{"type":"link","label":"Setting displayName","href":"/Component/5-6-Setting displayName","docId":"Component/5-6-Setting displayName","unlisted":false},{"type":"link","label":"Considerations When Structuring Components","href":"/Component/5-7-Considerations When Structuring Components","docId":"Component/5-7-Considerations When Structuring Components","unlisted":false},{"type":"link","label":"Higher-Order Components (HOC)","href":"/Component/5-8-Higher-Order Components (HOC)","docId":"Component/5-8-Higher-Order Components (HOC)","unlisted":false}]},{"type":"category","label":"Rendering","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"Handling Whitespace in JSX","href":"/Rendering/6-1-Handling Whitespace in JSX","docId":"Rendering/6-1-Handling Whitespace in JSX","unlisted":false},{"type":"link","label":"Dealing with 0 (Zero) as a Valid Value in JSX","href":"/Rendering/6-2-Dealing with 0 (Zero) as a Valid Value in JSX","docId":"Rendering/6-2-Dealing with 0 (Zero) as a Valid Value in JSX","unlisted":false},{"type":"link","label":"How to Use Keys Inside Lists","href":"/Rendering/6-3-How to Use Keys Inside Lists","docId":"Rendering/6-3-How to Use Keys Inside Lists","unlisted":false},{"type":"link","label":"Safely Using Raw HTML","href":"/Rendering/6-4-Safely Using Raw HTML","docId":"Rendering/6-4-Safely Using Raw HTML","unlisted":false},{"type":"link","label":"Dynamic Rendering and Conditional Rendering","href":"/Rendering/6-5-Dynamic Rendering and Conditional Rendering","docId":"Rendering/6-5-Dynamic Rendering and Conditional Rendering","unlisted":false}]},{"type":"category","label":"Hook","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"Reviewing useState, useRef, and useEffect","href":"/Hook/7-1-Reviewing useState, useRef, and useEffect","docId":"Hook/7-1-Reviewing useState, useRef, and useEffect","unlisted":false},{"type":"link","label":"Types of Custom Hook Returns","href":"/Hook/7-10-Types of Custom Hook Returns","docId":"Hook/7-10-Types of Custom Hook Returns","unlisted":false},{"type":"link","label":"Extracting State Logic with Custom Hooks","href":"/Hook/7-11-Extracting State Logic with Custom Hooks","docId":"Hook/7-11-Extracting State Logic with Custom Hooks","unlisted":false},{"type":"link","label":"useContext","href":"/Hook/7-2-useContext","docId":"Hook/7-2-useContext","unlisted":false},{"type":"link","label":"useCallback","href":"/Hook/7-3-useCallback","docId":"Hook/7-3-useCallback","unlisted":false},{"type":"link","label":"useMemo","href":"/Hook/7-4-useMemo","docId":"Hook/7-4-useMemo","unlisted":false},{"type":"link","label":"useReducer","href":"/Hook/7-5-useReducer","docId":"Hook/7-5-useReducer","unlisted":false},{"type":"link","label":"useLayoutEffect","href":"/Hook/7-6-useLayoutEffect","docId":"Hook/7-6-useLayoutEffect","unlisted":false},{"type":"link","label":"Differences Between useLayoutEffect and useEffect","href":"/Hook/7-7-Differences Between useLayoutEffect and useEffect","docId":"Hook/7-7-Differences Between useLayoutEffect and useEffect","unlisted":false},{"type":"link","label":"useImperativeHandle","href":"/Hook/7-8-useImperativeHandle","docId":"Hook/7-8-useImperativeHandle","unlisted":false},{"type":"link","label":"Custom Hooks","href":"/Hook/7-9-Custom Hooks","docId":"Hook/7-9-Custom Hooks","unlisted":false}]},{"type":"category","label":"Optimization","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"Techniques for Optimizing Component Performance","href":"/Optimization/8-1-Techniques for Optimizing Component Performance","docId":"Optimization/8-1-Techniques for Optimizing Component Performance","unlisted":false},{"type":"link","label":"Techniques for Optimizing Rendering","href":"/Optimization/8-2-Techniques for Optimizing Rendering","docId":"Optimization/8-2-Techniques for Optimizing Rendering","unlisted":false}]},{"type":"category","label":"Style","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"Inline Styling","href":"/Style/9-1-Inline Styling","docId":"Style/9-1-Inline Styling","unlisted":false},{"type":"link","label":"Emotion","href":"/Style/9-2-Emotion","docId":"Style/9-2-Emotion","unlisted":false},{"type":"link","label":"Styled-Components","href":"/Style/9-3-Styled-Components","docId":"Style/9-3-Styled-Components","unlisted":false},{"type":"link","label":"CSS Modules","href":"/Style/9-4-CSS Modules","docId":"Style/9-4-CSS Modules","unlisted":false},{"type":"link","label":"How to Use the clsx Library","href":"/Style/9-5-How to Use the clsx Library","docId":"Style/9-5-How to Use the clsx Library","unlisted":false},{"type":"link","label":"Managing Global Styles and Themes","href":"/Style/9-6-Managing Global Styles and Themes","docId":"Style/9-6-Managing Global Styles and Themes","unlisted":false},{"type":"link","label":"Comparison of CSS-in-JS and Traditional CSS","href":"/Style/9-7-Comparison of CSS-in-JS and Traditional CSS","docId":"Style/9-7-Comparison of CSS-in-JS and Traditional CSS","unlisted":false}]},{"type":"category","label":"End","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"React Community and Ecosystem","href":"/End/10-1-React Community and Ecosystem","docId":"End/10-1-React Community and Ecosystem","unlisted":false}]}]},"docs":{"Basic/1-1-Introduction to React and Setting Up Development Environment":{"id":"Basic/1-1-Introduction to React and Setting Up Development Environment","title":"Introduction to React and Setting Up Development Environment","description":"React.js is a powerful JavaScript library that helps developers build interactive and dynamic user interfaces, primarily for web applications. It was created by Facebook and has since become one of the most popular tools in the front-end development ecosystem. This introduction will guide you through the basics of React and how to set up your development environment to begin building React applications.","sidebar":"tutorialSidebar"},"Basic/1-2-Introduction to JSX and Expressing React Components":{"id":"Basic/1-2-Introduction to JSX and Expressing React Components","title":"Introduction to JSX and Expressing React Components","description":"React, at its core, revolves around components that represent pieces of a user interface. To build these components, we use JSX, which stands for JavaScript XML. JSX is a syntax extension for JavaScript that allows us to write HTML-like code within our JavaScript files. This makes it incredibly intuitive to describe what the UI should look like.","sidebar":"tutorialSidebar"},"Basic/1-3-Why Use Functional Components Instead of Class Components":{"id":"Basic/1-3-Why Use Functional Components Instead of Class Components","title":"Why Use Functional Components Instead of Class Components","description":"In modern React development, functional components have become the preferred way to build components, largely replacing the older class components. This shift isn\'t just a trend; it\'s grounded in the significant advantages that functional components offer. In this section, we\'ll explore the reasons behind this shift, using clear examples and explanations to illustrate the benefits.","sidebar":"tutorialSidebar"},"Basic/1-4-Passing Data to Components with Props":{"id":"Basic/1-4-Passing Data to Components with Props","title":"Passing Data to Components with Props","description":"In React, the flow of data is an essential concept, especially when building interactive user interfaces. One of the primary ways to transfer data between components in React is by using props. Props, short for \\"properties,\\" allow us to pass data from a parent component to its child components, enabling us to create dynamic and reusable components.","sidebar":"tutorialSidebar"},"Basic/1-5-Managing State with State":{"id":"Basic/1-5-Managing State with State","title":"Managing State with State","description":"In React, managing state effectively is crucial for building interactive and dynamic user interfaces. State represents the data that changes over time within a component, and React automatically re-renders components whenever the state changes. Understanding how to manage state is fundamental to creating responsive applications that feel fluid and natural to users.","sidebar":"tutorialSidebar"},"Basic/1-6-Handling Component Events":{"id":"Basic/1-6-Handling Component Events","title":"Handling Component Events","description":"React allows us to build interactive user interfaces by handling events in a way that is both simple and powerful. Understanding how to manage these events is essential to creating dynamic and responsive applications.","sidebar":"tutorialSidebar"},"Basic/1-7-Conditional Rendering and Iteration in JSX":{"id":"Basic/1-7-Conditional Rendering and Iteration in JSX","title":"Conditional Rendering and Iteration in JSX","description":"When working with React, one of the most powerful tools at your disposal is JSX, a syntax extension that allows you to write HTML-like code within JavaScript. Two essential techniques in JSX are conditional rendering and iteration. These techniques allow you to control what content is displayed to users and how lists of items are rendered dynamically. In this section, we will explore how to implement both conditional rendering and iteration in JSX with clear, easy-to-understand examples.","sidebar":"tutorialSidebar"},"Component/5-1-Introduction to Components and Good Component Naming Practices":{"id":"Component/5-1-Introduction to Components and Good Component Naming Practices","title":"Introduction to Components and Good Component Naming Practices","description":"React components are the building blocks of any React application. Understanding how to create and manage components effectively is crucial for developing scalable and maintainable applications. In this section, we\'ll explore the concept of React components and discuss best practices for naming them.","sidebar":"tutorialSidebar"},"Component/5-2-How to Use Self-Closing Tags":{"id":"Component/5-2-How to Use Self-Closing Tags","title":"How to Use Self-Closing Tags","description":"In React, understanding how to properly use self-closing tags is essential for writing clean and efficient JSX code. Self-closing tags simplify your code by reducing verbosity and avoiding potential errors that can arise from unclosed tags.","sidebar":"tutorialSidebar"},"Component/5-3-When and When Not to Use Fragments":{"id":"Component/5-3-When and When Not to Use Fragments","title":"When and When Not to Use Fragments","description":"React Fragments (` or the shorthand `) are a simple yet powerful tool in the React ecosystem that help manage and structure the rendering of elements. In this section, we will explore the specific scenarios where using Fragments is advantageous, as well as cases where they might not be necessary or beneficial.","sidebar":"tutorialSidebar"},"Component/5-4-Returning JSX from Component Functions":{"id":"Component/5-4-Returning JSX from Component Functions","title":"Returning JSX from Component Functions","description":"In React, components are the building blocks of your application. A fundamental concept in React is the ability to return JSX from component functions. JSX (JavaScript XML) is a syntax extension that looks similar to HTML and allows you to write what your UI should look like. Let\'s explore how to effectively return JSX from your component functions.","sidebar":"tutorialSidebar"},"Component/5-5-Declaring Inner Components Within Components":{"id":"Component/5-5-Declaring Inner Components Within Components","title":"Declaring Inner Components Within Components","description":"When working with React, you\'ll often encounter situations where a component is closely related to another component, yet it doesn\'t necessarily need to be accessible from outside its parent. In these cases, it can be beneficial to declare one component inside another. This approach not only keeps your code organized but also helps in managing the scope of components effectively.","sidebar":"tutorialSidebar"},"Component/5-6-Setting displayName":{"id":"Component/5-6-Setting displayName","title":"Setting displayName","description":"In React, the displayName property is a useful feature that allows you to specify the name of a component, which can be particularly helpful during debugging. By setting displayName, you ensure that React correctly identifies the component\'s name in development tools like React DevTools, which can be especially beneficial when dealing with higher-order components or anonymous components.","sidebar":"tutorialSidebar"},"Component/5-7-Considerations When Structuring Components":{"id":"Component/5-7-Considerations When Structuring Components","title":"Considerations When Structuring Components","description":"When building a React application, the way you structure your components can significantly impact the maintainability, readability, and scalability of your code. A well-structured component hierarchy enables easy updates, enhances code reuse, and simplifies debugging. This section will explore essential considerations when structuring components in React, providing practical examples and explanations along the way.","sidebar":"tutorialSidebar"},"Component/5-8-Higher-Order Components (HOC)":{"id":"Component/5-8-Higher-Order Components (HOC)","title":"Higher-Order Components (HOC)","description":"Higher-Order Components (HOCs) are a powerful and flexible pattern in React that allows you to reuse component logic across multiple components. Understanding HOCs is crucial for creating scalable and maintainable React applications. In this section, we\'ll dive into what HOCs are, how they work, and how you can use them effectively in your React projects.","sidebar":"tutorialSidebar"},"End/10-1-React Community and Ecosystem":{"id":"End/10-1-React Community and Ecosystem","title":"React Community and Ecosystem","description":"React.js, a popular JavaScript library for building user interfaces, has a thriving and active community that significantly contributes to its growth and evolution. Understanding this ecosystem is crucial for developers who want to stay updated, solve problems efficiently, and leverage the best practices in React development. This guide will walk you through the key components of the React community and ecosystem, providing you with a roadmap to becoming a well-rounded React developer.","sidebar":"tutorialSidebar"},"Hook/7-1-Reviewing useState, useRef, and useEffect":{"id":"Hook/7-1-Reviewing useState, useRef, and useEffect","title":"Reviewing useState, useRef, and useEffect","description":"When working with React, three hooks you\'ll frequently encounter are useState, useRef, and useEffect. These hooks are essential for managing state, referencing DOM elements or values, and handling side effects in functional components. In this section, we\'ll review how each of these hooks works, with concrete examples to deepen your understanding.","sidebar":"tutorialSidebar"},"Hook/7-10-Types of Custom Hook Returns":{"id":"Hook/7-10-Types of Custom Hook Returns","title":"Types of Custom Hook Returns","description":"When creating custom hooks in React, one of the key considerations is what the hook should return. The return value of a custom hook shapes how the hook will be used by the components that call it. A well-designed return structure can make the hook more versatile, easier to use, and more intuitive. In this section, we will explore various types of return values for custom hooks, with clear examples to illustrate each type.","sidebar":"tutorialSidebar"},"Hook/7-11-Extracting State Logic with Custom Hooks":{"id":"Hook/7-11-Extracting State Logic with Custom Hooks","title":"Extracting State Logic with Custom Hooks","description":"In React, managing state effectively is crucial for building scalable and maintainable applications. However, as your application grows, you might find that certain state management logic is being repeated across multiple components. This not only leads to code duplication but can also make your application harder to maintain and understand. Custom Hooks in React provide a powerful way to extract and reuse state logic across your components, leading to cleaner and more modular code.","sidebar":"tutorialSidebar"},"Hook/7-2-useContext":{"id":"Hook/7-2-useContext","title":"useContext","description":"The useContext hook is a fundamental tool in React that enables you to share data across multiple components without the need to pass props down through every level of the component tree. This can greatly simplify your component structure and improve code readability, especially in larger applications where data needs to be accessible by many components.","sidebar":"tutorialSidebar"},"Hook/7-3-useCallback":{"id":"Hook/7-3-useCallback","title":"useCallback","description":"In React, optimizing performance is essential, especially when working with large applications where re-rendering can become a bottleneck. One powerful tool to help with this is the useCallback hook. useCallback is primarily used to memoize functions so that they do not get recreated unnecessarily during re-renders, thus improving performance.","sidebar":"tutorialSidebar"},"Hook/7-4-useMemo":{"id":"Hook/7-4-useMemo","title":"useMemo","description":"The useMemo hook in React is a powerful tool that helps optimize the performance of your components by memoizing expensive computations. This means that useMemo allows you to cache the result of a calculation and reuse it until the dependencies change, avoiding unnecessary re-computations.","sidebar":"tutorialSidebar"},"Hook/7-5-useReducer":{"id":"Hook/7-5-useReducer","title":"useReducer","description":"The useReducer hook is a powerful tool in React that allows you to manage complex state logic in a more predictable and structured way. While useState is often sufficient for managing state in many scenarios, useReducer excels when you need to handle state transitions that involve multiple, interdependent actions. This hook is particularly useful when your state logic includes actions like adding, removing, or updating items in an array or when the next state depends heavily on the previous one.","sidebar":"tutorialSidebar"},"Hook/7-6-useLayoutEffect":{"id":"Hook/7-6-useLayoutEffect","title":"useLayoutEffect","description":"The useLayoutEffect hook in React is a powerful tool that allows you to perform side effects in a component just before the DOM is updated. This is particularly useful when you need to make measurements or manipulate the DOM in a way that should be done synchronously before the browser has a chance to paint.","sidebar":"tutorialSidebar"},"Hook/7-7-Differences Between useLayoutEffect and useEffect":{"id":"Hook/7-7-Differences Between useLayoutEffect and useEffect","title":"Differences Between useLayoutEffect and useEffect","description":"In React, two important hooks that manage side effects are useEffect and useLayoutEffect. While they might seem similar at first glance, they serve distinct purposes and are triggered at different points in the rendering process. Understanding the differences between these two hooks is essential for optimizing your React applications and ensuring that your components behave as expected.","sidebar":"tutorialSidebar"},"Hook/7-8-useImperativeHandle":{"id":"Hook/7-8-useImperativeHandle","title":"useImperativeHandle","description":"The useImperativeHandle hook is one of the more advanced hooks in React. It allows you to customize the instance value that is exposed to parent components when using ref. This hook is particularly useful when you want to control the behavior or interface of a component in a way that isn\'t possible through normal props and state management.","sidebar":"tutorialSidebar"},"Hook/7-9-Custom Hooks":{"id":"Hook/7-9-Custom Hooks","title":"Custom Hooks","description":"React\'s custom hooks are a powerful tool that allows developers to extract and reuse stateful logic across different components. By understanding and utilizing custom hooks, you can make your code more modular, readable, and maintainable. In this section, we\'ll explore what custom hooks are, how to create them, and best practices for their use.","sidebar":"tutorialSidebar"},"index":{"id":"index","title":"Getting Started","description":"Quick Introduction and How to Use","sidebar":"tutorialSidebar"},"Life Cycle/4-1-Introduction to useEffect and Controlling the Life Cycle":{"id":"Life Cycle/4-1-Introduction to useEffect and Controlling the Life Cycle","title":"Introduction to useEffect and Controlling the Life Cycle","description":"The useEffect Hook in React is a fundamental tool for managing side effects and controlling the lifecycle of components. Understanding how and when to use useEffect is key to writing effective and efficient React applications. In this section, we\'ll explore the basics of useEffect, discuss its role in the component lifecycle, and provide practical examples to illustrate its use.","sidebar":"tutorialSidebar"},"Life Cycle/4-2-Using useEffect with Named Functions":{"id":"Life Cycle/4-2-Using useEffect with Named Functions","title":"Using useEffect with Named Functions","description":"The useEffect hook is a fundamental part of React\'s functional component API. It allows you to perform side effects in your components, such as fetching data, directly interacting with the DOM, or subscribing to external events. However, while it\'s common to define the effect\'s logic directly within the useEffect hook, a more organized and reusable approach is to use named functions.","sidebar":"tutorialSidebar"},"Life Cycle/4-3-Why useEffect Should Perform Only One Task":{"id":"Life Cycle/4-3-Why useEffect Should Perform Only One Task","title":"Why useEffect Should Perform Only One Task","description":"When working with React, one of the most powerful and commonly used hooks is useEffect. This hook allows you to handle side effects in your functional components, such as fetching data, directly interacting with the DOM, or managing subscriptions. However, to maintain clarity and ensure better code management, it\'s crucial that each useEffect performs only one task.","sidebar":"tutorialSidebar"},"Life Cycle/4-4-Managing Asynchronous Operations Inside useEffect":{"id":"Life Cycle/4-4-Managing Asynchronous Operations Inside useEffect","title":"Managing Asynchronous Operations Inside useEffect","description":"When working with React, one of the essential hooks you\'ll frequently use is useEffect. This hook is designed to handle side effects in your components, such as fetching data from an API, setting up a subscription, or manually changing the DOM. However, managing asynchronous operations within useEffect can be tricky, particularly due to the nature of JavaScript\'s asynchronous behavior and React\'s rendering process. In this section, we\u2019ll explore how to handle asynchronous operations inside useEffect effectively, ensuring your components behave predictably and efficiently.","sidebar":"tutorialSidebar"},"Optimization/8-1-Techniques for Optimizing Component Performance":{"id":"Optimization/8-1-Techniques for Optimizing Component Performance","title":"Techniques for Optimizing Component Performance","description":"React.js is designed to create highly interactive user interfaces. However, as your application grows in complexity, the performance of your components can become a critical concern. Optimizing component performance involves understanding how React works under the hood and applying specific techniques to ensure your app remains fast and responsive. In this section, we\'ll explore several strategies for optimizing component performance.","sidebar":"tutorialSidebar"},"Optimization/8-2-Techniques for Optimizing Rendering":{"id":"Optimization/8-2-Techniques for Optimizing Rendering","title":"Techniques for Optimizing Rendering","description":"When working with React, one of the most crucial aspects to consider is rendering performance. As your application grows in complexity, inefficient rendering can lead to sluggish performance, causing a poor user experience. Optimizing rendering involves techniques that ensure your React components only re-render when absolutely necessary. This section will walk you through several techniques and best practices for achieving optimal rendering performance in React.","sidebar":"tutorialSidebar"},"Props/3-1-Introduction to Props and Good Prop Naming Practices":{"id":"Props/3-1-Introduction to Props and Good Prop Naming Practices","title":"Introduction to Props and Good Prop Naming Practices","description":"In React, props (short for properties) are one of the core concepts that allow components to be reusable and customizable. Props are used to pass data from one component to another, typically from a parent component to a child component. Understanding how to use props effectively and adopting good prop naming practices is essential for writing clean, maintainable, and understandable React code.","sidebar":"tutorialSidebar"},"Props/3-2-Differences Between State and Props":{"id":"Props/3-2-Differences Between State and Props","title":"Differences Between State and Props","description":"Understanding the distinction between state and props is crucial in mastering React. These two concepts, although seemingly similar, serve distinct purposes and have different roles in the lifecycle of React components. Let\'s delve into their differences, supported by concrete code examples.","sidebar":"tutorialSidebar"},"Props/3-3-Examples of Avoiding Unnecessary Prop Copying and Operations":{"id":"Props/3-3-Examples of Avoiding Unnecessary Prop Copying and Operations","title":"Examples of Avoiding Unnecessary Prop Copying and Operations","description":"When working with React, understanding how to efficiently pass data between components is crucial. However, it\'s easy to fall into the trap of copying props unnecessarily or performing redundant operations, which can lead to performance bottlenecks and harder-to-maintain code. In this section, we\'ll explore practical examples and best practices for avoiding these pitfalls, ensuring your components remain lean and efficient.","sidebar":"tutorialSidebar"},"Props/3-4-Validating Types and Setting Default Values with PropTypes":{"id":"Props/3-4-Validating Types and Setting Default Values with PropTypes","title":"Validating Types and Setting Default Values with PropTypes","description":"In React, ensuring that your components receive the correct type of data and handle missing or undefined props gracefully is crucial for building reliable and maintainable applications. This is where PropTypes comes into play. PropTypes allow you to define the expected data types for the props your component receives, providing an extra layer of validation that helps catch bugs early in development. Additionally, setting default values for props ensures that your components behave predictably, even if some props are not passed from the parent component.","sidebar":"tutorialSidebar"},"Props/3-5-Important Points When Using Destructuring Assignment and ...props":{"id":"Props/3-5-Important Points When Using Destructuring Assignment and ...props","title":"Important Points When Using Destructuring Assignment and ...props","description":"When working with React components, understanding how to efficiently manage props is essential. Two powerful techniques for handling props are destructuring assignment and the use of the spread operator (...props). These techniques can simplify your code, make it more readable, and reduce the likelihood of errors. However, they also come with nuances that you must carefully consider to avoid potential pitfalls.","sidebar":"tutorialSidebar"},"Props/3-6-How to Use Shorthand Props":{"id":"Props/3-6-How to Use Shorthand Props","title":"How to Use Shorthand Props","description":"In React, props (short for \\"properties\\") are a way to pass data from a parent component to a child component. Shorthand props are a concise way to write props when the key and value are the same. This approach helps to make your code more readable and succinct.","sidebar":"tutorialSidebar"},"Props/3-7-Why Complex Props Should Be Split and the Benefits of Simple Props":{"id":"Props/3-7-Why Complex Props Should Be Split and the Benefits of Simple Props","title":"Why Complex Props Should Be Split and the Benefits of Simple Props","description":"When building React components, the management of props is crucial for maintaining clear, efficient, and reusable code. Complex props, which often consist of large objects or deeply nested structures, can make your components harder to understand, maintain, and test. By splitting complex props into simpler, more manageable pieces, you can create cleaner and more focused components. In this section, we\u2019ll explore why it\u2019s beneficial to split complex props and how to do it effectively.","sidebar":"tutorialSidebar"},"Props/3-9-defaultProps":{"id":"Props/3-9-defaultProps","title":"defaultProps","description":"In React, defaultProps is a useful feature for setting default values for props in a component. This becomes particularly handy when you want to ensure that your component has a fallback value for a prop if it was not provided by the parent component. Understanding how to use defaultProps effectively can help you write more robust and predictable React components.","sidebar":"tutorialSidebar"},"Rendering/6-1-Handling Whitespace in JSX":{"id":"Rendering/6-1-Handling Whitespace in JSX","title":"Handling Whitespace in JSX","description":"When working with JSX (JavaScript XML), managing whitespace can be a bit tricky, especially if you\'re coming from an HTML or other templating backgrounds. JSX, which is syntactically similar to HTML, is used in React to describe what the UI should look like. However, JSX has its own rules regarding whitespace, and understanding these rules is crucial to ensure your components render as expected.","sidebar":"tutorialSidebar"},"Rendering/6-2-Dealing with 0 (Zero) as a Valid Value in JSX":{"id":"Rendering/6-2-Dealing with 0 (Zero) as a Valid Value in JSX","title":"Dealing with 0 (Zero) as a Valid Value in JSX","description":"When working with JSX in React, it\u2019s crucial to understand how certain values, particularly 0, are handled during rendering. Since JSX is a syntax extension for JavaScript, the way JavaScript evaluates expressions directly impacts how JSX content is displayed. 0 is a special value in JavaScript because it is a falsy value, meaning it is treated as false in conditional expressions. However, unlike null, undefined, or false, 0 is still a valid and meaningful number, often used in contexts like counts, indexes, and measurements.","sidebar":"tutorialSidebar"},"Rendering/6-3-How to Use Keys Inside Lists":{"id":"Rendering/6-3-How to Use Keys Inside Lists","title":"How to Use Keys Inside Lists","description":"In React, when rendering a list of elements, each element must have a unique identifier known as a \\"key.\\" The key prop is crucial for React\'s reconciliation process, enabling it to efficiently update the user interface when data changes. Without proper keys, React will struggle to determine which items have changed, leading to potential performance issues or even incorrect rendering.","sidebar":"tutorialSidebar"},"Rendering/6-4-Safely Using Raw HTML":{"id":"Rendering/6-4-Safely Using Raw HTML","title":"Safely Using Raw HTML","description":"When developing applications with React, there may be scenarios where you need to incorporate raw HTML directly into your components. This might be necessary when dealing with third-party content, user-generated content, or converting content from another format into HTML. However, directly injecting raw HTML can introduce significant security risks, such as Cross-Site Scripting (XSS) attacks. This section will guide you through the best practices for safely using raw HTML in React.","sidebar":"tutorialSidebar"},"Rendering/6-5-Dynamic Rendering and Conditional Rendering":{"id":"Rendering/6-5-Dynamic Rendering and Conditional Rendering","title":"Dynamic Rendering and Conditional Rendering","description":"Dynamic rendering and conditional rendering are fundamental concepts in React that allow you to control what your application displays based on various conditions. Understanding these concepts will enable you to build interactive and responsive user interfaces that adjust content based on user interactions, data changes, or application state.","sidebar":"tutorialSidebar"},"State/2-1-Introduction to State and Good State Naming Practices":{"id":"State/2-1-Introduction to State and Good State Naming Practices","title":"Introduction to State and Good State Naming Practices","description":"State is one of the most fundamental concepts in React. It allows you to create dynamic and interactive user interfaces by keeping track of changes within a component. Unlike props, which are passed down from a parent component and remain fixed unless explicitly changed, state is local to a component and can be modified within that component. Understanding state and using good naming practices are crucial to writing clear, maintainable React code.","sidebar":"tutorialSidebar"},"State/2-2-Managing User Input with State":{"id":"State/2-2-Managing User Input with State","title":"Managing User Input with State","description":"Managing user input is a fundamental aspect of building interactive web applications with React. To achieve this effectively, understanding how to manage user input with state is crucial. In this section, we will explore how state in React helps us handle and manage user input dynamically, providing a seamless and responsive user experience.","sidebar":"tutorialSidebar"},"State/2-3-Setting Appropriate Initial Values and Removing Unnecessary State":{"id":"State/2-3-Setting Appropriate Initial Values and Removing Unnecessary State","title":"Setting Appropriate Initial Values and Removing Unnecessary State","description":"When working with React, managing state is crucial for building dynamic, interactive user interfaces. Two important aspects of state management are setting appropriate initial values and removing unnecessary state. These practices help ensure that your components are efficient, maintainable, and predictable.","sidebar":"tutorialSidebar"},"State/2-4-Identifying and Solving Issues with Non-updating Values":{"id":"State/2-4-Identifying and Solving Issues with Non-updating Values","title":"Identifying and Solving Issues with Non-updating Values","description":"When working with React, one of the common challenges developers face is dealing with state values that don\'t seem to update as expected. This issue can lead to bugs that are difficult to diagnose, especially for those who are new to React\'s way of managing state. In this section, we will explore common reasons why state values may not update correctly and how to solve these issues. We\'ll break down the concepts with concrete code examples to ensure clarity.","sidebar":"tutorialSidebar"},"State/2-5-Managing Flag States":{"id":"State/2-5-Managing Flag States","title":"Managing Flag States","description":"Managing flag states in React is crucial for controlling the flow and behavior of your components. A flag state is a boolean value (true or false) that typically represents a condition or status, such as whether a user is logged in, whether a modal is open, or whether a form is valid. These flag states allow you to create dynamic and interactive user interfaces.","sidebar":"tutorialSidebar"},"State/2-6-Simplifying and Structuring Related States":{"id":"State/2-6-Simplifying and Structuring Related States","title":"Simplifying and Structuring Related States","description":"When working with React, managing the state of your components effectively is crucial for building maintainable and bug-free applications. Often, you\'ll find that multiple pieces of state within a component are related, and handling them individually can lead to a messy and error-prone codebase. In this section, we\'ll explore strategies to simplify and structure related states, making your components cleaner and more predictable.","sidebar":"tutorialSidebar"},"State/2-7-Introduction to useRef and Creating Component Variables Instead of useState":{"id":"State/2-7-Introduction to useRef and Creating Component Variables Instead of useState","title":"Introduction to useRef and Creating Component Variables Instead of useState","description":"When developing with React, you\'ll often find yourself managing state within your components using useState. While useState is incredibly useful, there are situations where using useRef might be a better option. This guide will introduce you to useRef, explain when and why you might choose it over useState, and walk you through creating component variables that don\u2019t trigger re-renders, improving your application\'s performance and usability.","sidebar":"tutorialSidebar"},"State/2-8-Understanding the Asynchronous Nature of State Update Functions, Utilizing Previous States, and State Resetting":{"id":"State/2-8-Understanding the Asynchronous Nature of State Update Functions, Utilizing Previous States, and State Resetting","title":"Understanding the Asynchronous Nature of State Update Functions, Utilizing Previous States, and State Resetting","description":"React\'s state management is one of its most powerful features, allowing you to build dynamic, interactive user interfaces. However, to effectively use state, it\u2019s crucial to understand that state updates in React are asynchronous. This asynchronous behavior can have significant implications for how you manage and update state, especially when you need to rely on the current state value or reset the state based on previous states.","sidebar":"tutorialSidebar"},"Style/9-1-Inline Styling":{"id":"Style/9-1-Inline Styling","title":"Inline Styling","description":"When working with React, inline styling is a method of applying CSS styles directly to elements in your JSX. This approach is similar to how you might use the style attribute in traditional HTML, but with a few key differences that arise from the fact that React components are JavaScript functions. In this section, we\'ll explore how to effectively use inline styling, covering both the basics and some nuances to watch out for.","sidebar":"tutorialSidebar"},"Style/9-2-Emotion":{"id":"Style/9-2-Emotion","title":"Emotion","description":"Emotion is a popular library in the React ecosystem that allows developers to style components using CSS-in-JS (CSS in JavaScript). It provides powerful and flexible styling capabilities, enabling you to write styles directly within your JavaScript or TypeScript files. Emotion supports both inline styles and styled components, giving you the freedom to choose the approach that best fits your project.","sidebar":"tutorialSidebar"},"Style/9-3-Styled-Components":{"id":"Style/9-3-Styled-Components","title":"Styled-Components","description":"Styled-Components is a powerful library for React that allows you to write CSS directly within your JavaScript files, helping you to style your components more effectively. By using Styled-Components, you can keep your styles closely tied to the components they affect, ensuring better maintainability and reducing the chances of style conflicts.","sidebar":"tutorialSidebar"},"Style/9-4-CSS Modules":{"id":"Style/9-4-CSS Modules","title":"CSS Modules","description":"CSS Modules offer a way to write modular and reusable CSS that is scoped locally to individual components in a React application. This approach helps avoid the common problem of global scope in CSS, where styles can inadvertently affect elements that they were not intended for. In this section, we\'ll explore how to use CSS Modules effectively in your React projects.","sidebar":"tutorialSidebar"},"Style/9-5-How to Use the clsx Library":{"id":"Style/9-5-How to Use the clsx Library","title":"How to Use the clsx Library","description":"In React development, managing dynamic class names can become cumbersome, especially as your components grow in complexity. The clsx library is a lightweight utility that simplifies the process of conditionally joining class names together. It allows you to efficiently manage class names without having to write extensive conditional logic within your components. This is particularly useful when you have multiple classes that need to be applied based on various conditions.","sidebar":"tutorialSidebar"},"Style/9-6-Managing Global Styles and Themes":{"id":"Style/9-6-Managing Global Styles and Themes","title":"Managing Global Styles and Themes","description":"In any React application, managing global styles and themes is essential for ensuring a consistent look and feel across all components. This task can be approached in various ways, depending on the complexity of your application and the specific styling needs. In this section, we\'ll explore how to handle global styles and themes efficiently using different techniques available in the React ecosystem.","sidebar":"tutorialSidebar"},"Style/9-7-Comparison of CSS-in-JS and Traditional CSS":{"id":"Style/9-7-Comparison of CSS-in-JS and Traditional CSS","title":"Comparison of CSS-in-JS and Traditional CSS","description":"CSS (Cascading Style Sheets) is the cornerstone of web design, allowing developers to control the look and feel of web applications. Traditionally, CSS has been written in external .css files and linked to HTML documents. However, with the rise of modern JavaScript frameworks like React, new approaches to styling have emerged, notably CSS-in-JS. This section will explore the differences between CSS-in-JS and traditional CSS, highlighting the advantages and disadvantages of each approach.","sidebar":"tutorialSidebar"}}}}')}}]);