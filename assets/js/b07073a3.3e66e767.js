"use strict";(self.webpackChunkdocubook=self.webpackChunkdocubook||[]).push([[402],{3497:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>a,contentTitle:()=>o,default:()=>u,frontMatter:()=>i,metadata:()=>c,toc:()=>d});var s=t(4848),r=t(8453);const i={},o="Introduction to useRef and Creating Component Variables Instead of useState",c={id:"State/2-7-Introduction to useRef and Creating Component Variables Instead of useState",title:"Introduction to useRef and Creating Component Variables Instead of useState",description:"When developing with React, you'll often find yourself managing state within your components using useState. While useState is incredibly useful, there are situations where using useRef might be a better option. This guide will introduce you to useRef, explain when and why you might choose it over useState, and walk you through creating component variables that don\u2019t trigger re-renders, improving your application's performance and usability.",source:"@site/docs/2-State/2-7-Introduction to useRef and Creating Component Variables Instead of useState.md",sourceDirName:"2-State",slug:"/State/2-7-Introduction to useRef and Creating Component Variables Instead of useState",permalink:"/State/2-7-Introduction to useRef and Creating Component Variables Instead of useState",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Simplifying and Structuring Related States",permalink:"/State/2-6-Simplifying and Structuring Related States"},next:{title:"Understanding the Asynchronous Nature of State Update Functions, Utilizing Previous States, and State Resetting",permalink:"/State/2-8-Understanding the Asynchronous Nature of State Update Functions, Utilizing Previous States, and State Resetting"}},a={},d=[{value:"What is <code>useRef</code>?",id:"what-is-useref",level:2},{value:"Basic Usage of <code>useRef</code>",id:"basic-usage-of-useref",level:3},{value:"When to Use <code>useRef</code> Instead of <code>useState</code>",id:"when-to-use-useref-instead-of-usestate",level:3},{value:"Creating Component Variables with <code>useRef</code>",id:"creating-component-variables-with-useref",level:3},{value:"Key Points to Remember",id:"key-points-to-remember",level:3},{value:"Further Reading",id:"further-reading",level:2},{value:"Summary",id:"summary",level:2}];function l(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h1,{id:"introduction-to-useref-and-creating-component-variables-instead-of-usestate",children:"Introduction to useRef and Creating Component Variables Instead of useState"}),"\n",(0,s.jsxs)(n.p,{children:["When developing with React, you'll often find yourself managing state within your components using ",(0,s.jsx)(n.code,{children:"useState"}),". While ",(0,s.jsx)(n.code,{children:"useState"})," is incredibly useful, there are situations where using ",(0,s.jsx)(n.code,{children:"useRef"})," might be a better option. This guide will introduce you to ",(0,s.jsx)(n.code,{children:"useRef"}),", explain when and why you might choose it over ",(0,s.jsx)(n.code,{children:"useState"}),", and walk you through creating component variables that don\u2019t trigger re-renders, improving your application's performance and usability."]}),"\n",(0,s.jsxs)(n.h2,{id:"what-is-useref",children:["What is ",(0,s.jsx)(n.code,{children:"useRef"}),"?"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"useRef"})," is a hook in React that returns a mutable object. This object has a ",(0,s.jsx)(n.code,{children:".current"})," property, which you can set to any value. Unlike ",(0,s.jsx)(n.code,{children:"useState"}),", updating this ",(0,s.jsx)(n.code,{children:".current"})," property does ",(0,s.jsx)(n.strong,{children:"not"})," cause a component to re-render. This makes ",(0,s.jsx)(n.code,{children:"useRef"})," perfect for storing values that don't directly impact the visual output of your component, such as:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"DOM elements"}),"\n",(0,s.jsx)(n.li,{children:"Timers"}),"\n",(0,s.jsx)(n.li,{children:"Previous values"}),"\n",(0,s.jsx)(n.li,{children:"Persistent values across renders"}),"\n"]}),"\n",(0,s.jsxs)(n.h3,{id:"basic-usage-of-useref",children:["Basic Usage of ",(0,s.jsx)(n.code,{children:"useRef"})]}),"\n",(0,s.jsxs)(n.p,{children:["Let's start with a simple example where we use ",(0,s.jsx)(n.code,{children:"useRef"})," to keep track of a DOM element:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-jsx",children:'import React, { useRef, useEffect } from \'react\';\n\nfunction FocusInput() {\n  // Create a ref to store the input element\n  const inputRef = useRef(null);\n\n  // Focus the input element when the component mounts\n  useEffect(() => {\n    inputRef.current.focus(); // Access the DOM node through the ref\n  }, []);\n\n  return (\n    <input ref={inputRef} type="text" placeholder="Focus me on mount!" />\n  );\n}\n\nexport default FocusInput;\n'})}),"\n",(0,s.jsxs)(n.h3,{id:"when-to-use-useref-instead-of-usestate",children:["When to Use ",(0,s.jsx)(n.code,{children:"useRef"})," Instead of ",(0,s.jsx)(n.code,{children:"useState"})]}),"\n",(0,s.jsxs)(n.p,{children:["There are specific scenarios where ",(0,s.jsx)(n.code,{children:"useRef"})," is more appropriate than ",(0,s.jsx)(n.code,{children:"useState"}),":"]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Storing Non-Render-Related Data"}),": If you need to store data that doesn\u2019t affect the UI, ",(0,s.jsx)(n.code,{children:"useRef"})," is your go-to. For example, tracking the number of times a button is clicked within a session but not displaying that count in the UI."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-jsx",children:"function ClickTracker() {\n  const clickCount = useRef(0); // Initial value of 0\n\n  const handleClick = () => {\n    clickCount.current += 1; // Increment the count\n    console.log(`Button clicked ${clickCount.current} times`);\n  };\n\n  return (\n    <button onClick={handleClick}>\n      Click me\n    </button>\n  );\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Here, ",(0,s.jsx)(n.code,{children:"clickCount"})," is incremented with every click, but since it\u2019s not used in rendering, the component doesn\u2019t re-render unnecessarily."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Referencing DOM Elements"}),": As shown in the first example, ",(0,s.jsx)(n.code,{children:"useRef"})," is ideal for referencing DOM elements and performing actions like focusing or measuring dimensions."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Storing Mutable Objects"}),": If you\u2019re dealing with objects or arrays that you need to persist across renders without triggering a re-render, ",(0,s.jsx)(n.code,{children:"useRef"})," is appropriate."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Avoiding Re-Renders with Stable References"}),": Using ",(0,s.jsx)(n.code,{children:"useRef"})," can also help maintain stable references to objects or functions between renders, especially when passing them as dependencies to ",(0,s.jsx)(n.code,{children:"useEffect"})," or callbacks."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.h3,{id:"creating-component-variables-with-useref",children:["Creating Component Variables with ",(0,s.jsx)(n.code,{children:"useRef"})]}),"\n",(0,s.jsxs)(n.p,{children:["Consider a situation where you want to implement a simple timer in your component. Using ",(0,s.jsx)(n.code,{children:"useRef"}),", you can store a reference to the timer ID without triggering re-renders."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-jsx",children:"import React, { useRef, useState } from 'react';\n\nfunction Timer() {\n  const [seconds, setSeconds] = useState(0);\n  const timerId = useRef(null); // Ref to store the timer ID\n\n  const startTimer = () => {\n    if (timerId.current) return; // Prevent multiple timers\n    timerId.current = setInterval(() => {\n      setSeconds(prevSeconds => prevSeconds + 1);\n    }, 1000);\n  };\n\n  const stopTimer = () => {\n    clearInterval(timerId.current);\n    timerId.current = null; // Reset the ref\n  };\n\n  return (\n    <div>\n      <p>Timer: {seconds} seconds</p>\n      <button onClick={startTimer}>Start</button>\n      <button onClick={stopTimer}>Stop</button>\n    </div>\n  );\n}\n\nexport default Timer;\n"})}),"\n",(0,s.jsx)(n.p,{children:"In this example:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"useRef"})," is used to store the timer ID, which doesn\u2019t need to trigger a re-render when it changes."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"useState"})," manages the ",(0,s.jsx)(n.code,{children:"seconds"}),", which needs to be re-rendered each second."]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"key-points-to-remember",children:"Key Points to Remember"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsxs)(n.strong,{children:[(0,s.jsx)(n.code,{children:"useRef"})," does not trigger re-renders"]}),": Updating the ",(0,s.jsx)(n.code,{children:".current"})," property will not cause the component to re-render."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Perfect for storing mutable objects"}),": Use ",(0,s.jsx)(n.code,{children:"useRef"})," for values that need to persist across renders without affecting the UI."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Great for referencing DOM elements"}),": ",(0,s.jsx)(n.code,{children:"useRef"})," is a handy way to directly access and manipulate DOM nodes."]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"further-reading",children:"Further Reading"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.strong,{children:"React Refs"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.strong,{children:"Managing State vs. Refs"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.strong,{children:"useState vs. useRef"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.strong,{children:"React Performance Optimization"})}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"useRef"})," is a powerful React hook for creating mutable references to values or DOM elements that persist across renders without causing re-renders. It's particularly useful for storing non-UI related data, maintaining stable references, and managing DOM elements. Understanding when to use ",(0,s.jsx)(n.code,{children:"useRef"})," instead of ",(0,s.jsx)(n.code,{children:"useState"})," is key to writing efficient and effective React components."]})]})}function u(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>c});var s=t(6540);const r={},i=s.createContext(r);function o(e){const n=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),s.createElement(i.Provider,{value:n},e.children)}}}]);