"use strict";(self.webpackChunkdocubook=self.webpackChunkdocubook||[]).push([[2145],{946:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>i,default:()=>l,frontMatter:()=>r,metadata:()=>a,toc:()=>u});var s=n(4848),o=n(8453);const r={},i="useLayoutEffect",a={id:"Hook/7-6-useLayoutEffect",title:"useLayoutEffect",description:"The useLayoutEffect hook in React is a powerful tool that allows you to perform side effects in a component just before the DOM is updated. This is particularly useful when you need to make measurements or manipulate the DOM in a way that should be done synchronously before the browser has a chance to paint.",source:"@site/docs/7-Hook/7-6-useLayoutEffect.md",sourceDirName:"7-Hook",slug:"/Hook/7-6-useLayoutEffect",permalink:"/Hook/7-6-useLayoutEffect",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"useReducer",permalink:"/Hook/7-5-useReducer"},next:{title:"Differences Between useLayoutEffect and useEffect",permalink:"/Hook/7-7-Differences Between useLayoutEffect and useEffect"}},c={},u=[{value:"What is <code>useLayoutEffect</code>?",id:"what-is-uselayouteffect",level:2},{value:"Syntax",id:"syntax",level:3},{value:"Key Concepts",id:"key-concepts",level:3},{value:"Example: Measuring and Adjusting Layout",id:"example-measuring-and-adjusting-layout",level:2},{value:"Explanation",id:"explanation",level:3},{value:"Why <code>useLayoutEffect</code>?",id:"why-uselayouteffect",level:3},{value:"Points to Watch Out For",id:"points-to-watch-out-for",level:2},{value:"Further Reading",id:"further-reading",level:2},{value:"Summary",id:"summary",level:2}];function d(e){const t={code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.h1,{id:"uselayouteffect",children:"useLayoutEffect"}),"\n",(0,s.jsxs)(t.p,{children:["The ",(0,s.jsx)(t.code,{children:"useLayoutEffect"})," hook in React is a powerful tool that allows you to perform side effects in a component just before the DOM is updated. This is particularly useful when you need to make measurements or manipulate the DOM in a way that should be done synchronously before the browser has a chance to paint."]}),"\n",(0,s.jsxs)(t.p,{children:["Understanding when and how to use ",(0,s.jsx)(t.code,{children:"useLayoutEffect"})," is key to optimizing the performance and correctness of your React components."]}),"\n",(0,s.jsxs)(t.h2,{id:"what-is-uselayouteffect",children:["What is ",(0,s.jsx)(t.code,{children:"useLayoutEffect"}),"?"]}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.code,{children:"useLayoutEffect"})," is similar to ",(0,s.jsx)(t.code,{children:"useEffect"}),", but with one key difference: it fires synchronously after all DOM mutations but before the browser repaints. This means that if you need to read layout information from the DOM and then make changes, those changes will happen before the browser actually renders the screen, avoiding potential flicker."]}),"\n",(0,s.jsx)(t.h3,{id:"syntax",children:"Syntax"}),"\n",(0,s.jsxs)(t.p,{children:["The syntax of ",(0,s.jsx)(t.code,{children:"useLayoutEffect"})," is almost identical to ",(0,s.jsx)(t.code,{children:"useEffect"}),":"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-javascript",children:"useLayoutEffect(() => {\n  // Your side effect logic here\n\n  return () => {\n    // Cleanup logic here (optional)\n  };\n}, [dependencies]);\n"})}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Callback Function"}),": The first argument is the callback function where you place your side effect code."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Dependencies Array"}),": The second argument is an array of dependencies. The effect will re-run whenever any of the dependencies change."]}),"\n"]}),"\n",(0,s.jsx)(t.h3,{id:"key-concepts",children:"Key Concepts"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Synchronous Execution"}),": ",(0,s.jsx)(t.code,{children:"useLayoutEffect"})," runs synchronously, which means it blocks the browser from painting until the effect is executed. This can prevent flickering issues but can also slow down rendering if overused."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"DOM Interaction"}),": Ideal for scenarios where you need to measure the DOM (e.g., getting the size or position of an element) and then make changes based on those measurements."]}),"\n"]}),"\n",(0,s.jsx)(t.h2,{id:"example-measuring-and-adjusting-layout",children:"Example: Measuring and Adjusting Layout"}),"\n",(0,s.jsxs)(t.p,{children:["Let's look at an example where ",(0,s.jsx)(t.code,{children:"useLayoutEffect"})," is particularly useful. Suppose you want to measure the width of a DOM element and adjust another element's style based on that measurement."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-javascript",children:"import React, { useLayoutEffect, useRef, useState } from 'react';\n\nfunction LayoutComponent() {\n  const boxRef = useRef(null); // Create a ref to access the DOM element\n  const [boxWidth, setBoxWidth] = useState(0); // State to store the width of the box\n\n  useLayoutEffect(() => {\n    // Measure the width of the box\n    const width = boxRef.current.offsetWidth;\n\n    // Set the measured width to state\n    setBoxWidth(width);\n\n    // Apply some style adjustment based on the width\n    if (width > 200) {\n      boxRef.current.style.backgroundColor = 'lightcoral';\n    } else {\n      boxRef.current.style.backgroundColor = 'lightblue';\n    }\n  }, [boxWidth]); // Dependency array includes boxWidth to re-run the effect if it changes\n\n  return (\n    <div>\n      <div ref={boxRef} style={{ width: '50%', padding: '20px', border: '1px solid black' }}>\n        Resize the window to see the background color change.\n      </div>\n      <p>The width of the box is: {boxWidth}px</p>\n    </div>\n  );\n}\n\nexport default LayoutComponent;\n"})}),"\n",(0,s.jsx)(t.h3,{id:"explanation",children:"Explanation"}),"\n",(0,s.jsxs)(t.ol,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"useRef Hook"}),": We use ",(0,s.jsx)(t.code,{children:"useRef"})," to get a reference to the DOM element whose width we want to measure."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"useLayoutEffect"}),": Inside this hook, we measure the width of the box using ",(0,s.jsx)(t.code,{children:"offsetWidth"})," and then set that value in state using ",(0,s.jsx)(t.code,{children:"setBoxWidth"}),"."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Conditional Styling"}),": Based on the measured width, we apply conditional styling to the box. The background color changes depending on the width."]}),"\n"]}),"\n",(0,s.jsxs)(t.h3,{id:"why-uselayouteffect",children:["Why ",(0,s.jsx)(t.code,{children:"useLayoutEffect"}),"?"]}),"\n",(0,s.jsxs)(t.p,{children:["In this case, using ",(0,s.jsx)(t.code,{children:"useLayoutEffect"})," ensures that the width is measured and the background color is set before the browser repaints the screen, preventing any visual glitches or flickering."]}),"\n",(0,s.jsx)(t.h2,{id:"points-to-watch-out-for",children:"Points to Watch Out For"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Performance Impact"}),": Since ",(0,s.jsx)(t.code,{children:"useLayoutEffect"})," runs synchronously, it can delay the browser's painting. Avoid using it for tasks that don't require immediate DOM measurements or updates."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Only When Necessary"}),": Use ",(0,s.jsx)(t.code,{children:"useLayoutEffect"})," sparingly. For most side effects that don't involve DOM measurement or manipulation, ",(0,s.jsx)(t.code,{children:"useEffect"})," is the preferred choice."]}),"\n"]}),"\n",(0,s.jsx)(t.h2,{id:"further-reading",children:"Further Reading"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"React DOM"}),": Learn more about how the React DOM works and how it interacts with hooks."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Performance Optimization"}),": Explore techniques to optimize component performance, particularly in complex applications."]}),"\n"]}),"\n",(0,s.jsx)(t.h2,{id:"summary",children:"Summary"}),"\n",(0,s.jsxs)(t.p,{children:["The ",(0,s.jsx)(t.code,{children:"useLayoutEffect"})," hook is essential for scenarios where you need to measure and manipulate the DOM before the browser repaints. It runs synchronously after DOM updates but before the paint, making it ideal for tasks that require precise control over the rendering process. Use it carefully to avoid unnecessary performance hits, and prefer ",(0,s.jsx)(t.code,{children:"useEffect"})," for most side effects that don't require immediate DOM interaction."]})]})}function l(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>i,x:()=>a});var s=n(6540);const o={},r=s.createContext(o);function i(e){const t=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:i(e.components),s.createElement(r.Provider,{value:t},e.children)}}}]);