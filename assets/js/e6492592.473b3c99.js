"use strict";(self.webpackChunkdocubook=self.webpackChunkdocubook||[]).push([[6413],{3941:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>s,default:()=>d,frontMatter:()=>a,metadata:()=>r,toc:()=>l});var o=t(4848),i=t(8453);const a={},s="useMemo",r={id:"Hook/7-4-useMemo",title:"useMemo",description:"The useMemo hook in React is a powerful tool that helps optimize the performance of your components by memoizing expensive computations. This means that useMemo allows you to cache the result of a calculation and reuse it until the dependencies change, avoiding unnecessary re-computations.",source:"@site/docs/7-Hook/7-4-useMemo.md",sourceDirName:"7-Hook",slug:"/Hook/7-4-useMemo",permalink:"/Hook/7-4-useMemo",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"useCallback",permalink:"/Hook/7-3-useCallback"},next:{title:"useReducer",permalink:"/Hook/7-5-useReducer"}},c={},l=[{value:"Understanding useMemo",id:"understanding-usememo",level:2},{value:"Syntax",id:"syntax",level:3},{value:"Example: Memoizing a Computation",id:"example-memoizing-a-computation",level:2},{value:"Explanation of the Example",id:"explanation-of-the-example",level:3},{value:"Key Points to Watch Out For",id:"key-points-to-watch-out-for",level:3},{value:"Further Reading",id:"further-reading",level:2},{value:"Summary",id:"summary",level:2}];function u(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.h1,{id:"usememo",children:"useMemo"}),"\n",(0,o.jsxs)(n.p,{children:["The ",(0,o.jsx)(n.code,{children:"useMemo"})," hook in React is a powerful tool that helps optimize the performance of your components by memoizing expensive computations. This means that ",(0,o.jsx)(n.code,{children:"useMemo"})," allows you to cache the result of a calculation and reuse it until the dependencies change, avoiding unnecessary re-computations."]}),"\n",(0,o.jsx)(n.h2,{id:"understanding-usememo",children:"Understanding useMemo"}),"\n",(0,o.jsxs)(n.p,{children:["In React, when a component re-renders, all the functions inside it are re-executed. While React is efficient, if a function performs heavy computations, recalculating every time can slow down the application. The ",(0,o.jsx)(n.code,{children:"useMemo"})," hook addresses this issue by allowing you to store the result of an expensive calculation and reuse it unless specific dependencies change."]}),"\n",(0,o.jsx)(n.h3,{id:"syntax",children:"Syntax"}),"\n",(0,o.jsxs)(n.p,{children:["The basic syntax of ",(0,o.jsx)(n.code,{children:"useMemo"})," is as follows:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-javascript",children:"const memoizedValue = useMemo(() => {\n  // your expensive computation here\n  return computedResult;\n}, [dependency1, dependency2]);\n"})}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"The first argument is a function that returns the value you want to memoize."}),"\n",(0,o.jsx)(n.li,{children:"The second argument is an array of dependencies. When any of these dependencies change, the function will re-run and recalculate the value."}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"example-memoizing-a-computation",children:"Example: Memoizing a Computation"}),"\n",(0,o.jsxs)(n.p,{children:["Let's look at a concrete example where ",(0,o.jsx)(n.code,{children:"useMemo"})," can be beneficial."]}),"\n",(0,o.jsx)(n.p,{children:"Suppose you have a component that calculates the factorial of a number. Calculating factorials for large numbers is computationally intensive, and you don't want to recalculate it unnecessarily on every render."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-javascript",children:'import React, { useState, useMemo } from \'react\';\n\n// Function to calculate factorial\nconst factorial = (n) => {\n  console.log("Calculating factorial...");\n  if (n <= 0) return 1;\n  return n * factorial(n - 1);\n};\n\nconst FactorialComponent = () => {\n  const [number, setNumber] = useState(1);\n  const [increment, setIncrement] = useState(0);\n\n  // Memoize the factorial calculation\n  const factorialResult = useMemo(() => factorial(number), [number]);\n\n  return (\n    <div>\n      <h2>Factorial Calculator</h2>\n      \n      {/* Input to change the number */}\n      <input\n        type="number"\n        value={number}\n        onChange={(e) => setNumber(parseInt(e.target.value))}\n      />\n      \n      <p>Factorial of {number} is: {factorialResult}</p>\n      \n      {/* Button to trigger an unrelated state change */}\n      <button onClick={() => setIncrement(increment + 1)}>\n        Increment Counter: {increment}\n      </button>\n    </div>\n  );\n};\n\nexport default FactorialComponent;\n'})}),"\n",(0,o.jsx)(n.h3,{id:"explanation-of-the-example",children:"Explanation of the Example"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Factorial Calculation:"})," The ",(0,o.jsx)(n.code,{children:"factorial"})," function is a recursive function that computes the factorial of a given number. This is an example of an expensive operation, especially for large numbers."]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"useMemo Implementation:"})," We wrap the ",(0,o.jsx)(n.code,{children:"factorial"})," function call inside a ",(0,o.jsx)(n.code,{children:"useMemo"})," hook, which memoizes the result. The dependency array contains only ",(0,o.jsx)(n.code,{children:"number"}),", so the factorial will only be recalculated when ",(0,o.jsx)(n.code,{children:"number"})," changes."]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"State Management:"})," The component also has a button that updates a counter. However, thanks to ",(0,o.jsx)(n.code,{children:"useMemo"}),", updating this counter does not trigger a recalculation of the factorial unless ",(0,o.jsx)(n.code,{children:"number"})," has changed."]}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"key-points-to-watch-out-for",children:"Key Points to Watch Out For"}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:[(0,o.jsxs)(n.strong,{children:["When to Use ",(0,o.jsx)(n.code,{children:"useMemo"}),":"]})," Only use ",(0,o.jsx)(n.code,{children:"useMemo"})," when you have an expensive computation that needs optimization. Overusing it or using it for trivial calculations might actually lead to worse performance due to the overhead of memoization."]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Dependencies Matter:"})," The dependency array is crucial. If you omit a dependency or include unnecessary ones, the memoization may not work as expected, leading to either unnecessary recalculations or stale values."]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Returning a Value, Not a Function:"})," Remember that ",(0,o.jsx)(n.code,{children:"useMemo"})," is used to memoize a value, not a function. If you want to memoize a function, consider using ",(0,o.jsx)(n.code,{children:"useCallback"}),"."]}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"further-reading",children:"Further Reading"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.strong,{children:"React Hooks"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.strong,{children:"Performance Optimization in React"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.strong,{children:"Memoization Techniques"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.strong,{children:"React Rendering Behavior"})}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,o.jsxs)(n.p,{children:["The ",(0,o.jsx)(n.code,{children:"useMemo"})," hook in React is an essential tool for optimizing the performance of components that rely on expensive computations. By caching the result and recalculating only when necessary, ",(0,o.jsx)(n.code,{children:"useMemo"})," helps avoid unnecessary re-computations, thus enhancing the efficiency of your React applications. However, it should be used judiciously, with careful attention to dependencies, to achieve the desired performance improvements."]})]})}function d(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(u,{...e})}):u(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>r});var o=t(6540);const i={},a=o.createContext(i);function s(e){const n=o.useContext(a);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),o.createElement(a.Provider,{value:n},e.children)}}}]);