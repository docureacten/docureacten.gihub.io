"use strict";(self.webpackChunkdocubook=self.webpackChunkdocubook||[]).push([[7300],{5885:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>s,metadata:()=>r,toc:()=>a});var c=t(4848),i=t(8453);const s={},o="useCallback",r={id:"Hook/7-3-useCallback",title:"useCallback",description:"In React, optimizing performance is essential, especially when working with large applications where re-rendering can become a bottleneck. One powerful tool to help with this is the useCallback hook. useCallback is primarily used to memoize functions so that they do not get recreated unnecessarily during re-renders, thus improving performance.",source:"@site/docs/7-Hook/7-3-useCallback.md",sourceDirName:"7-Hook",slug:"/Hook/7-3-useCallback",permalink:"/Hook/7-3-useCallback",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"useContext",permalink:"/Hook/7-2-useContext"},next:{title:"useMemo",permalink:"/Hook/7-4-useMemo"}},l={},a=[{value:"What is <code>useCallback</code>?",id:"what-is-usecallback",level:2},{value:"Syntax of <code>useCallback</code>",id:"syntax-of-usecallback",level:3},{value:"Breaking Down the Syntax",id:"breaking-down-the-syntax",level:3},{value:"Example: Understanding <code>useCallback</code> in Practice",id:"example-understanding-usecallback-in-practice",level:2},{value:"Explanation of the Example",id:"explanation-of-the-example",level:3},{value:"Key Points to Remember",id:"key-points-to-remember",level:3},{value:"Further Reading",id:"further-reading",level:2},{value:"Summary",id:"summary",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,c.jsxs)(c.Fragment,{children:[(0,c.jsx)(n.h1,{id:"usecallback",children:"useCallback"}),"\n",(0,c.jsxs)(n.p,{children:["In React, optimizing performance is essential, especially when working with large applications where re-rendering can become a bottleneck. One powerful tool to help with this is the ",(0,c.jsx)(n.code,{children:"useCallback"})," hook. ",(0,c.jsx)(n.code,{children:"useCallback"})," is primarily used to memoize functions so that they do not get recreated unnecessarily during re-renders, thus improving performance."]}),"\n",(0,c.jsxs)(n.h2,{id:"what-is-usecallback",children:["What is ",(0,c.jsx)(n.code,{children:"useCallback"}),"?"]}),"\n",(0,c.jsxs)(n.p,{children:["The ",(0,c.jsx)(n.code,{children:"useCallback"})," hook returns a memoized version of the callback function that only changes if one of the dependencies has changed. This is particularly useful when passing callback functions to optimized child components that rely on reference equality to prevent unnecessary renders."]}),"\n",(0,c.jsxs)(n.h3,{id:"syntax-of-usecallback",children:["Syntax of ",(0,c.jsx)(n.code,{children:"useCallback"})]}),"\n",(0,c.jsxs)(n.p,{children:["Here\u2019s the basic syntax of ",(0,c.jsx)(n.code,{children:"useCallback"}),":"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-javascript",children:"const memoizedCallback = useCallback(\n  () => {\n    // Your logic here\n  },\n  [dependency1, dependency2] // dependencies array\n);\n"})}),"\n",(0,c.jsx)(n.h3,{id:"breaking-down-the-syntax",children:"Breaking Down the Syntax"}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.strong,{children:(0,c.jsx)(n.code,{children:"() => { /* Your logic here */ }"})}),": This is the function you want to memoize. It will only be recreated if one of the dependencies in the array changes."]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.strong,{children:(0,c.jsx)(n.code,{children:"[dependency1, dependency2]"})}),": These are the dependencies for your callback. If any of these dependencies change, the callback function will be recreated. If none of them change, the function retains its previous reference, preventing unnecessary re-renders."]}),"\n"]}),"\n",(0,c.jsxs)(n.h2,{id:"example-understanding-usecallback-in-practice",children:["Example: Understanding ",(0,c.jsx)(n.code,{children:"useCallback"})," in Practice"]}),"\n",(0,c.jsxs)(n.p,{children:["Let\u2019s look at an example to better understand how ",(0,c.jsx)(n.code,{children:"useCallback"})," works:"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-javascript",children:"import React, { useState, useCallback } from 'react';\n\n// A button component that only re-renders when the callback function changes\nconst Button = React.memo(({ onClick, children }) => {\n  console.log('Button rendered:', children);\n  return <button onClick={onClick}>{children}</button>;\n});\n\nfunction Counter() {\n  const [count, setCount] = useState(0);\n  const [incrementValue, setIncrementValue] = useState(1);\n\n  // Memoize the increment function\n  const increment = useCallback(() => {\n    setCount((prevCount) => prevCount + incrementValue);\n  }, [incrementValue]); // Dependency on incrementValue\n\n  return (\n    <div>\n      <p>Count: {count}</p>\n      <Button onClick={increment}>Increment by {incrementValue}</Button>\n      <input\n        type=\"number\"\n        value={incrementValue}\n        onChange={(e) => setIncrementValue(Number(e.target.value))}\n      />\n    </div>\n  );\n}\n\nexport default Counter;\n"})}),"\n",(0,c.jsx)(n.h3,{id:"explanation-of-the-example",children:"Explanation of the Example"}),"\n",(0,c.jsxs)(n.ol,{children:["\n",(0,c.jsxs)(n.li,{children:["\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.strong,{children:(0,c.jsx)(n.code,{children:"Button Component"})}),": The ",(0,c.jsx)(n.code,{children:"Button"})," component is wrapped in ",(0,c.jsx)(n.code,{children:"React.memo"}),", which means it will only re-render if its props change. Since ",(0,c.jsx)(n.code,{children:"useCallback"})," memoizes the ",(0,c.jsx)(n.code,{children:"increment"})," function, the ",(0,c.jsx)(n.code,{children:"Button"})," component will not re-render unnecessarily when the ",(0,c.jsx)(n.code,{children:"Counter"})," component re-renders unless ",(0,c.jsx)(n.code,{children:"incrementValue"})," changes."]}),"\n"]}),"\n",(0,c.jsxs)(n.li,{children:["\n",(0,c.jsxs)(n.p,{children:[(0,c.jsxs)(n.strong,{children:[(0,c.jsx)(n.code,{children:"useCallback"})," Hook"]}),": The ",(0,c.jsx)(n.code,{children:"increment"})," function is memoized using ",(0,c.jsx)(n.code,{children:"useCallback"}),", which takes the current ",(0,c.jsx)(n.code,{children:"incrementValue"})," as a dependency. This means the ",(0,c.jsx)(n.code,{children:"increment"})," function will only be recreated when ",(0,c.jsx)(n.code,{children:"incrementValue"})," changes, preventing the ",(0,c.jsx)(n.code,{children:"Button"})," component from re-rendering when it is not necessary."]}),"\n"]}),"\n"]}),"\n",(0,c.jsx)(n.h3,{id:"key-points-to-remember",children:"Key Points to Remember"}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsxs)(n.li,{children:["\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.strong,{children:"Memoization"}),": The primary purpose of ",(0,c.jsx)(n.code,{children:"useCallback"})," is to prevent unnecessary re-creation of functions, especially useful in performance-sensitive applications."]}),"\n"]}),"\n",(0,c.jsxs)(n.li,{children:["\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.strong,{children:"Dependencies"}),": Always include all the variables that your callback function depends on in the dependencies array. Failing to do so might lead to stale or incorrect data being used in your function."]}),"\n"]}),"\n",(0,c.jsxs)(n.li,{children:["\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.strong,{children:"Use in Optimized Components"}),": ",(0,c.jsx)(n.code,{children:"useCallback"})," is often used in combination with ",(0,c.jsx)(n.code,{children:"React.memo"})," to optimize child components and prevent unnecessary renders."]}),"\n"]}),"\n"]}),"\n",(0,c.jsx)(n.h2,{id:"further-reading",children:"Further Reading"}),"\n",(0,c.jsx)(n.p,{children:"To dive deeper into related concepts and further optimize your React applications, consider looking into the following topics:"}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsx)(n.li,{children:(0,c.jsx)(n.strong,{children:"React.memo"})}),"\n",(0,c.jsx)(n.li,{children:(0,c.jsx)(n.strong,{children:"useMemo"})}),"\n",(0,c.jsx)(n.li,{children:(0,c.jsx)(n.strong,{children:"React Performance Optimization Techniques"})}),"\n",(0,c.jsx)(n.li,{children:(0,c.jsx)(n.strong,{children:"Understanding React's Reconciliation Process"})}),"\n"]}),"\n",(0,c.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,c.jsxs)(n.p,{children:["The ",(0,c.jsx)(n.code,{children:"useCallback"})," hook is a powerful tool in React that allows developers to memoize functions, reducing the risk of unnecessary re-renders. By controlling when a function is recreated using dependencies, ",(0,c.jsx)(n.code,{children:"useCallback"})," helps in optimizing the performance of React applications, particularly when passing functions to child components. Remember to correctly manage dependencies and use this hook in contexts where re-rendering could affect performance."]})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,c.jsx)(n,{...e,children:(0,c.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>r});var c=t(6540);const i={},s=c.createContext(i);function o(e){const n=c.useContext(s);return c.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),c.createElement(s.Provider,{value:n},e.children)}}}]);