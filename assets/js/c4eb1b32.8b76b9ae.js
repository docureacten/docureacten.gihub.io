"use strict";(self.webpackChunkdocubook=self.webpackChunkdocubook||[]).push([[4161],{6327:(e,n,o)=>{o.r(n),o.d(n,{assets:()=>l,contentTitle:()=>i,default:()=>d,frontMatter:()=>a,metadata:()=>r,toc:()=>c});var t=o(4848),s=o(8453);const a={},i="Extracting State Logic with Custom Hooks",r={id:"Hook/7-11-Extracting State Logic with Custom Hooks",title:"Extracting State Logic with Custom Hooks",description:"In React, managing state effectively is crucial for building scalable and maintainable applications. However, as your application grows, you might find that certain state management logic is being repeated across multiple components. This not only leads to code duplication but can also make your application harder to maintain and understand. Custom Hooks in React provide a powerful way to extract and reuse state logic across your components, leading to cleaner and more modular code.",source:"@site/docs/7-Hook/7-11-Extracting State Logic with Custom Hooks.md",sourceDirName:"7-Hook",slug:"/Hook/7-11-Extracting State Logic with Custom Hooks",permalink:"/Hook/7-11-Extracting State Logic with Custom Hooks",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Types of Custom Hook Returns",permalink:"/Hook/7-10-Types of Custom Hook Returns"},next:{title:"useContext",permalink:"/Hook/7-2-useContext"}},l={},c=[{value:"What Are Custom Hooks?",id:"what-are-custom-hooks",level:2},{value:"When Should You Use Custom Hooks?",id:"when-should-you-use-custom-hooks",level:2},{value:"Creating a Simple Custom Hook",id:"creating-a-simple-custom-hook",level:2},{value:"Example: <code>useFormInput</code> Custom Hook",id:"example-useforminput-custom-hook",level:3},{value:"Explanation of the Example",id:"explanation-of-the-example",level:3},{value:"Benefits of Using Custom Hooks",id:"benefits-of-using-custom-hooks",level:2},{value:"Further Reading",id:"further-reading",level:2},{value:"Summary",id:"summary",level:2}];function u(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h1,{id:"extracting-state-logic-with-custom-hooks",children:"Extracting State Logic with Custom Hooks"}),"\n",(0,t.jsx)(n.p,{children:"In React, managing state effectively is crucial for building scalable and maintainable applications. However, as your application grows, you might find that certain state management logic is being repeated across multiple components. This not only leads to code duplication but can also make your application harder to maintain and understand. Custom Hooks in React provide a powerful way to extract and reuse state logic across your components, leading to cleaner and more modular code."}),"\n",(0,t.jsx)(n.h2,{id:"what-are-custom-hooks",children:"What Are Custom Hooks?"}),"\n",(0,t.jsxs)(n.p,{children:["A ",(0,t.jsx)(n.strong,{children:"Custom Hook"}),' is a JavaScript function whose name starts with "use" and that can call other Hooks (like ',(0,t.jsx)(n.code,{children:"useState"}),", ",(0,t.jsx)(n.code,{children:"useEffect"}),", etc.). Custom Hooks allow you to encapsulate reusable logic and share it across different components without repeating the code. By extracting common state management logic into a Custom Hook, you keep your components focused on rendering and behavior, rather than on the intricacies of state management."]}),"\n",(0,t.jsx)(n.h2,{id:"when-should-you-use-custom-hooks",children:"When Should You Use Custom Hooks?"}),"\n",(0,t.jsx)(n.p,{children:"You should consider using a Custom Hook when you notice that:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Several components share the same state logic."}),"\n",(0,t.jsx)(n.li,{children:"You have complex state management logic that you want to abstract for reusability."}),"\n",(0,t.jsx)(n.li,{children:"You want to cleanly separate concerns in your application."}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"creating-a-simple-custom-hook",children:"Creating a Simple Custom Hook"}),"\n",(0,t.jsx)(n.p,{children:"Let's start with a practical example. Imagine you have a form in multiple components where you need to manage the input fields' values and their changes. Instead of writing the same logic in each component, you can extract this logic into a Custom Hook."}),"\n",(0,t.jsxs)(n.h3,{id:"example-useforminput-custom-hook",children:["Example: ",(0,t.jsx)(n.code,{children:"useFormInput"})," Custom Hook"]}),"\n",(0,t.jsxs)(n.p,{children:["Here's how you can create a Custom Hook called ",(0,t.jsx)(n.code,{children:"useFormInput"})," that handles the state of a form input:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"import { useState } from 'react';\n\n// Custom Hook: useFormInput\nfunction useFormInput(initialValue) {\n  const [value, setValue] = useState(initialValue);\n\n  // Function to handle input changes\n  const handleChange = (e) => {\n    setValue(e.target.value);\n  };\n\n  // Return the value and the onChange handler\n  return {\n    value,\n    onChange: handleChange,\n  };\n}\n\n// Example component using useFormInput\nfunction UserForm() {\n  const nameInput = useFormInput(''); // Initialize with an empty string\n  const emailInput = useFormInput(''); // Initialize with an empty string\n\n  // Render the form\n  return (\n    <form>\n      <div>\n        <label>Name:</label>\n        <input type=\"text\" {...nameInput} /> {/* Spread the returned object */}\n      </div>\n      <div>\n        <label>Email:</label>\n        <input type=\"email\" {...emailInput} />\n      </div>\n      <button type=\"submit\">Submit</button>\n    </form>\n  );\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"explanation-of-the-example",children:"Explanation of the Example"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"useFormInput Hook"}),": This Hook manages the state for a form input field. It initializes the state with an ",(0,t.jsx)(n.code,{children:"initialValue"})," and provides a ",(0,t.jsx)(n.code,{children:"handleChange"})," function to update the state whenever the input value changes."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Returning an Object"}),": The ",(0,t.jsx)(n.code,{children:"useFormInput"})," Hook returns an object containing the current ",(0,t.jsx)(n.code,{children:"value"})," and an ",(0,t.jsx)(n.code,{children:"onChange"})," function. This object can then be spread directly onto the input elements (",(0,t.jsx)(n.code,{children:"<input {...nameInput} />"}),"), making it easy to use in your component."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Reusability"}),": The ",(0,t.jsx)(n.code,{children:"useFormInput"})," Hook can be reused for any input field across different forms or components, making the code more modular and easier to maintain."]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"benefits-of-using-custom-hooks",children:"Benefits of Using Custom Hooks"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Reusability"}),": Custom Hooks allow you to reuse stateful logic across multiple components, reducing code duplication and making your application more DRY (Don't Repeat Yourself)."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Encapsulation"}),": By encapsulating complex logic in a Custom Hook, you keep your components focused on their primary responsibilities\u2014rendering UI\u2014while the Hook handles the state management."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Testability"}),": Custom Hooks make it easier to test state logic in isolation. You can write tests specifically for the Hook without involving the component's rendering logic."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Abstraction"}),": Custom Hooks enable you to abstract away the details of how state is managed, providing a simpler and cleaner interface for your components."]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"further-reading",children:"Further Reading"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"React Hooks documentation"}),": To explore more about how to use Hooks in React."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Advanced patterns with Custom Hooks"}),": Learn about more complex use cases for Custom Hooks."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Testing Custom Hooks"}),": Techniques for effectively testing your Custom Hooks."]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,t.jsx)(n.p,{children:"Custom Hooks are a powerful tool in React that allow you to extract and reuse state logic across multiple components. By encapsulating common state management patterns into Custom Hooks, you can write cleaner, more modular, and maintainable code. Custom Hooks help to abstract complex logic, promote code reuse, and improve the testability of your state management logic. By leveraging Custom Hooks, you can ensure your components remain focused on rendering and user interactions, while the state logic is handled in a consistent and reusable manner."})]})}function d(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(u,{...e})}):u(e)}},8453:(e,n,o)=>{o.d(n,{R:()=>i,x:()=>r});var t=o(6540);const s={},a=t.createContext(s);function i(e){const n=t.useContext(a);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),t.createElement(a.Provider,{value:n},e.children)}}}]);